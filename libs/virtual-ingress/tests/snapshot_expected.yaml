---
# Source: virtual-ingress/templates/rbac.yaml
# RBAC for Kyverno to perform service discovery and ingress generation
# Grants permissions to:
# - Read services (for label-based service discovery)
# - Create/manage ingresses (for generating resolved ingresses)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kyverno-virtual-ingress
  labels:
    helm.sh/chart: virtual-ingress-0.1.0
    app.kubernetes.io/name: virtual-ingress
    app.kubernetes.io/instance: virtual-ingress
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/managed-by: Helm
rules:
  # Service discovery - read services by labels
  - apiGroups:
      - ""
    resources:
      - services
    verbs:
      - get
      - list
      - watch
  # Ingress management - create and manage generated ingresses
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingresses
    verbs:
      - create
      - update
      - patch
      - delete
      - get
      - list
      - watch
---
# Source: virtual-ingress/templates/rbac.yaml
# Bind the ClusterRole to Kyverno service accounts
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kyverno-virtual-ingress
  labels:
    helm.sh/chart: virtual-ingress-0.1.0
    app.kubernetes.io/name: virtual-ingress
    app.kubernetes.io/instance: virtual-ingress
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/managed-by: Helm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kyverno-virtual-ingress
subjects:
  # Background controller handles generate rules with synchronize
  - kind: ServiceAccount
    name: kyverno-background-controller
    namespace: kyverno
  # Admission controller handles initial generate on resource creation
  - kind: ServiceAccount
    name: kyverno-admission-controller
    namespace: kyverno
---
# Source: virtual-ingress/templates/clusterpolicy-virtual-ingress.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: generate-virtual-ingress
  annotations:
    policies.kyverno.io/title: Resolve Virtual Ingress Service Labels
    policies.kyverno.io/category: Networking
    policies.kyverno.io/severity: medium
    policies.kyverno.io/subject: Ingress
    policies.kyverno.io/description: >-
      Resolves Ingress resources that use matchLabels instead of direct service names.
      When an Ingress backend specifies matchLabels, this policy queries the Kubernetes API
      to find matching services and generates a resolved Ingress with the actual service name.
      Supports configurable behavior for no-match and multiple-match scenarios.
    # Hash of immutable fields - used by pre-upgrade hook to detect changes
    virtual-ingress/immutable-hash: "b77fc95e89582621"
  labels:
    helm.sh/chart: virtual-ingress-0.1.0
    app.kubernetes.io/name: virtual-ingress
    app.kubernetes.io/instance: virtual-ingress
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/managed-by: Helm
spec:
  generateExisting: true
  background: true
  rules:
    # Validation rule: reject if no service matches
    - name: validate-service-exists
      match:
        any:
          - resources:
              kinds:
                - Ingress
      preconditions:
        all:
          - key: "{{ request.object.spec.rules[0].http.paths[0].backend.service.matchLabels || '' | length(@) }}"
            operator: GreaterThan
            value: 0
          - key: '{{ request.object.metadata.annotations."virtual-ingress/processed" || '''' }}'
            operator: NotEquals
            value: "true"
      context:
        - name: matchLabels
          variable:
            jmesPath: "request.object.spec.rules[0].http.paths[0].backend.service.matchLabels"
        - name: serviceNamespace
          variable:
            jmesPath: "request.object.metadata.namespace"
        - name: clusterName
          variable:
            jmesPath: 'matchLabels."cluster.x-k8s.io/cluster-name" || ````'
        - name: tenantServiceName
          variable:
            jmesPath: 'matchLabels."cluster.x-k8s.io/tenant-service-name" || ````'
        - name: matchingServices
          apiCall:
            urlPath: "/api/v1/namespaces/{{serviceNamespace}}/services?labelSelector=cluster.x-k8s.io/cluster-name%3D{{clusterName}},cluster.x-k8s.io/tenant-service-name%3D{{tenantServiceName}}"
            jmesPath: "items"
        - name: matchCount
          variable:
            jmesPath: "length(matchingServices)"
      validate:
        message: "No service found matching labels: cluster.x-k8s.io/cluster-name={{clusterName}}, cluster.x-k8s.io/tenant-service-name={{tenantServiceName}} in namespace {{serviceNamespace}}"
        deny:
          conditions:
            all:
              - key: "{{ matchCount }}"
                operator: Equals
                value: 0
    # Validation rule: reject if multiple services match
    - name: validate-single-service
      match:
        any:
          - resources:
              kinds:
                - Ingress
      preconditions:
        all:
          - key: "{{ request.object.spec.rules[0].http.paths[0].backend.service.matchLabels || '' | length(@) }}"
            operator: GreaterThan
            value: 0
          - key: '{{ request.object.metadata.annotations."virtual-ingress/processed" || '''' }}'
            operator: NotEquals
            value: "true"
      context:
        - name: matchLabels
          variable:
            jmesPath: "request.object.spec.rules[0].http.paths[0].backend.service.matchLabels"
        - name: serviceNamespace
          variable:
            jmesPath: "request.object.metadata.namespace"
        - name: clusterName
          variable:
            jmesPath: 'matchLabels."cluster.x-k8s.io/cluster-name" || ````'
        - name: tenantServiceName
          variable:
            jmesPath: 'matchLabels."cluster.x-k8s.io/tenant-service-name" || ````'
        - name: matchingServices
          apiCall:
            urlPath: "/api/v1/namespaces/{{serviceNamespace}}/services?labelSelector=cluster.x-k8s.io/cluster-name%3D{{clusterName}},cluster.x-k8s.io/tenant-service-name%3D{{tenantServiceName}}"
            jmesPath: "items"
        - name: matchCount
          variable:
            jmesPath: "length(matchingServices)"
      validate:
        message: "Multiple services found matching labels. Found {{matchCount}} services. Please ensure labels uniquely identify a single service."
        deny:
          conditions:
            all:
              - key: "{{ matchCount }}"
                operator: GreaterThan
                value: 1
    # Generate rule: resolve service from matchLabels and create resolved ingress
    - name: resolve-service-from-labels
      match:
        any:
          - resources:
              kinds:
                - Ingress
      # Only process ingresses that have matchLabels in their backend
      preconditions:
        all:
          # Must have matchLabels defined (check first path as example)
          - key: "{{ request.object.spec.rules[0].http.paths[0].backend.service.matchLabels || '' | length(@) }}"
            operator: GreaterThan
            value: 0
          # Don't process already-resolved ingresses to avoid recursion
          - key: '{{ request.object.metadata.annotations."virtual-ingress/processed" || '''' }}'
            operator: NotEquals
            value: "true"
      # Query services using the API
      context:
        # Extract the matchLabels from the ingress
        - name: matchLabels
          variable:
            jmesPath: "request.object.spec.rules[0].http.paths[0].backend.service.matchLabels"
        # Get namespace for service lookup
        - name: serviceNamespace
          variable:
            jmesPath: "request.object.metadata.namespace"
        # Build a label selector string for the API query
        # Note: This works with common label patterns like cluster.x-k8s.io labels
        - name: clusterName
          variable:
            jmesPath: 'matchLabels."cluster.x-k8s.io/cluster-name" || ````'
        - name: tenantServiceName
          variable:
            jmesPath: 'matchLabels."cluster.x-k8s.io/tenant-service-name" || ````'
        # Query services in the namespace with label selector
        - name: matchingServices
          apiCall:
            urlPath: "/api/v1/namespaces/{{serviceNamespace}}/services?labelSelector=cluster.x-k8s.io/cluster-name%3D{{clusterName}},cluster.x-k8s.io/tenant-service-name%3D{{tenantServiceName}}"
            jmesPath: "items"
        # Get first matching service name (for single match or 'first' behavior)
        - name: resolvedServiceName
          variable:
            jmesPath: "matchingServices[0].metadata.name || ''"
        # Get port from source ingress
        - name: servicePort
          variable:
            jmesPath: "request.object.spec.rules[0].http.paths[0].backend.service.port.number"
      # Generate the resolved ingress
      generate:
        synchronize: true
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        name: "{{ request.object.metadata.name }}-resolved"
        namespace: "{{ request.object.metadata.namespace }}"
        data:
          metadata:
            labels:
              virtual-ingress.io/source-name: "{{ request.object.metadata.name }}"
              virtual-ingress.io/source-namespace: "{{ request.object.metadata.namespace }}"
              app.kubernetes.io/managed-by: kyverno
              kyverno.io/generated-by: generate-virtual-ingress
            annotations:
              virtual-ingress/processed: "true"
              virtual-ingress/source-ingress: "{{ request.object.metadata.name }}"
              virtual-ingress/resolved-service: "{{ resolvedServiceName }}"
            ownerReferences:
              - apiVersion: networking.k8s.io/v1
                kind: Ingress
                name: "{{ request.object.metadata.name }}"
                uid: "{{ request.object.metadata.uid }}"
                blockOwnerDeletion: true
                controller: true
          spec:
            # Copy ingressClassName from source
            ingressClassName: "{{ request.object.spec.ingressClassName }}"
            # Generate rules with resolved service name
            rules:
              - host: "{{ request.object.spec.rules[0].host }}"
                http:
                  paths:
                    - path: "{{ request.object.spec.rules[0].http.paths[0].path }}"
                      pathType: "{{ request.object.spec.rules[0].http.paths[0].pathType }}"
                      backend:
                        service:
                          name: "{{ resolvedServiceName }}"
                          port:
                            number: "{{ servicePort }}"
            # Copy TLS config if present
            tls: "{{ request.object.spec.tls }}"
