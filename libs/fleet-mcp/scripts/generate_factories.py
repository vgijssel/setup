#!/usr/bin/env python3
"""
Generate Python fixture factories from recorded JSON responses.

This script reads JSON recordings from the recording script and generates
Python fixture factory functions that can be used in tests.

Usage:
    python scripts/generate_factories.py
    python scripts/generate_factories.py --input recordings/ --output tests/fixtures/generated.py
"""

import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Any

from jinja2 import Template

# Template for generated Python file
GENERATED_FILE_TEMPLATE = '''"""
Auto-generated fixture factories from recorded HTTP responses.

DO NOT EDIT THIS FILE MANUALLY!
Generated by: scripts/generate_factories.py
Last updated: {{ timestamp }}

These fixtures are generated from real Coder API responses recorded using
the recording script (scripts/record_fixtures.py).

Usage:
    from tests.fixtures import generated

    # Use in tests
    workspace = generated.make_workspace_real()
    templates = generated.make_list_templates_real()
"""

from typing import Any


{% for fixture in fixtures %}
def {{ fixture.function_name }}() -> {{ fixture.return_type }}:
    """{{ fixture.docstring }}

    Generated from: {{ fixture.source_file }}
    Endpoint: {{ fixture.method }} {{ fixture.endpoint }}
    Status: {{ fixture.status_code }}
    Recorded: {{ fixture.recorded_at }}
    """
    return {{ fixture.data }}

{% endfor %}
'''


class FixtureGenerator:
    """Generates Python fixture factories from JSON recordings."""

    def __init__(self, input_dir: Path, output_file: Path):
        """
        Initialize generator.

        Args:
            input_dir: Directory containing JSON recordings
            output_file: Output Python file path
        """
        self.input_dir = input_dir
        self.output_file = output_file
        self.fixtures: list[dict] = []

    def generate(self) -> None:
        """Generate fixture factories from all recordings."""
        print(f"Scanning for recordings in {self.input_dir}...")

        # Find all JSON recording files
        recording_files = sorted(self.input_dir.glob("*.json"))

        if not recording_files:
            print(f"⚠ No recording files found in {self.input_dir}")
            print("Run scripts/record_fixtures.py first to create recordings")
            return

        print(f"Found {len(recording_files)} recording file(s)")

        # Process each recording file
        for recording_file in recording_files:
            print(f"\nProcessing: {recording_file.name}")
            self._process_recording_file(recording_file)

        # Generate output file
        if self.fixtures:
            self._write_output()
            print(f"\n✓ Generated {len(self.fixtures)} fixtures to {self.output_file}")
        else:
            print("\n⚠ No fixtures generated")

    def _process_recording_file(self, file_path: Path) -> None:
        """
        Process a single recording file.

        Args:
            file_path: Path to JSON recording file
        """
        with open(file_path) as f:
            recordings = json.load(f)

        if not isinstance(recordings, list):
            print(f"  ⚠ Skipping {file_path.name}: not a list of recordings")
            return

        for recording in recordings:
            fixture = self._create_fixture(recording, file_path.name)
            if fixture:
                self.fixtures.append(fixture)
                print(f"  + {fixture['function_name']}")

    def _create_fixture(self, recording: dict, source_file: str) -> dict | None:
        """
        Create a fixture definition from a recording.

        Args:
            recording: Recording dictionary
            source_file: Source file name

        Returns:
            Fixture definition or None if invalid
        """
        name = recording.get("name")
        endpoint = recording.get("endpoint", "")
        method = recording.get("method", "GET")
        status_code = recording.get("status_code", 200)
        data = recording.get("data")
        recorded_at = recording.get("recorded_at", "unknown")

        if not name or data is None:
            return None

        # Generate function name from recording name
        function_name = f"make_{self._normalize_name(name)}_real"

        # Determine return type based on data structure
        return_type = self._infer_return_type(data)

        # Generate docstring
        docstring = self._generate_docstring(name, endpoint, method)

        # Format data with proper indentation
        formatted_data = self._format_data(data, indent_level=1)

        return {
            "function_name": function_name,
            "return_type": return_type,
            "docstring": docstring,
            "source_file": source_file,
            "endpoint": endpoint,
            "method": method,
            "status_code": status_code,
            "recorded_at": recorded_at,
            "data": formatted_data,
        }

    def _normalize_name(self, name: str) -> str:
        """
        Normalize a recording name to a valid Python function name.

        Args:
            name: Recording name

        Returns:
            Normalized function name
        """
        # Replace non-alphanumeric with underscore
        normalized = "".join(c if c.isalnum() else "_" for c in name)

        # Remove consecutive underscores
        while "__" in normalized:
            normalized = normalized.replace("__", "_")

        # Remove leading/trailing underscores
        normalized = normalized.strip("_").lower()

        return normalized

    def _infer_return_type(self, data: Any) -> str:
        """
        Infer Python type annotation from data.

        Args:
            data: Data to infer type from

        Returns:
            Type annotation string
        """
        if isinstance(data, dict):
            return "dict[str, Any]"
        elif isinstance(data, list):
            return "list[Any]"
        elif isinstance(data, str):
            return "str"
        elif isinstance(data, (int, float)):
            return "int | float"
        elif isinstance(data, bool):
            return "bool"
        else:
            return "Any"

    def _generate_docstring(self, name: str, endpoint: str, method: str) -> str:
        """
        Generate docstring for fixture function.

        Args:
            name: Recording name
            endpoint: API endpoint
            method: HTTP method

        Returns:
            Docstring text
        """
        # Convert snake_case/kebab-case to Title Case
        title = name.replace("_", " ").replace("-", " ").title()
        return f"{title} fixture from real Coder API"

    def _format_data(self, data: Any, indent_level: int = 0) -> str:
        """
        Format data structure as Python code.

        Args:
            data: Data to format
            indent_level: Indentation level

        Returns:
            Formatted Python code string
        """
        # Use json.dumps with indent for pretty formatting
        # Then convert to Python syntax (true→True, false→False, null→None)
        json_str = json.dumps(data, indent=4)
        python_str = (
            json_str.replace("true", "True")
            .replace("false", "False")
            .replace("null", "None")
        )

        # Add indentation if needed
        if indent_level > 0:
            lines = python_str.split("\n")
            indented = "\n".join("    " * indent_level + line for line in lines)
            return indented.lstrip()

        return python_str

    def _write_output(self) -> None:
        """Write generated fixtures to output file."""
        template = Template(GENERATED_FILE_TEMPLATE)

        content = template.render(
            timestamp=datetime.now().isoformat(),
            fixtures=self.fixtures,
        )

        # Ensure output directory exists
        self.output_file.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        with open(self.output_file, "w") as f:
            f.write(content)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Generate fixture factories from JSON recordings"
    )
    parser.add_argument(
        "--input",
        type=Path,
        help="Input directory containing recordings (default: tests/fixtures/recordings/)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Output Python file (default: tests/fixtures/generated.py)",
    )
    args = parser.parse_args()

    # Default paths
    script_dir = Path(__file__).parent
    project_dir = script_dir.parent

    input_dir = args.input or (project_dir / "tests" / "fixtures" / "recordings")
    output_file = args.output or (project_dir / "tests" / "fixtures" / "generated.py")

    # Create generator and run
    generator = FixtureGenerator(input_dir=input_dir, output_file=output_file)
    generator.generate()


if __name__ == "__main__":
    main()
