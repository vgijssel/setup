{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello and welcome!","text":""},{"location":"#what-is-this-place","title":"What is this place?!","text":"<p>This is my personal blog where I write about my experiences, failures, successes and other things that interests me. It also houses documentation for all of my experiments an projects. I hope you find something useful here.</p>"},{"location":"#about-me","title":"About Me","text":"<p>I am a passionate developer with a strong focus on delivering business value. I\u2019m good at learning new languages, technologies and tools to innovatively solve new and existing problems. I have substantial subject matter experience in security, securing systems, data and CI/CD. I\u2019m a natural problem solver with an easy personality who likes to get things done.</p> <p>To the blog!</p>"},{"location":"blog/lessons-learned-deploying-pikvm/","title":"Deploying PiKVM: 7 Lessons You Already Know","text":"<p>TL;DR If you are thinking about using the Raspberry Pi 4 (Pi) which hosts PiKVM for multiple use cases, just get a second Pi. It will save you a lot of time.</p> <p>Having not read the PiKVM documentation thoroughly (reading is hard after all) I decided to purchase the Geekworm KVM-A3 with a Pi 8GiB instead of the recommend 1GiB to host both the PiKVM OS and Windmill inside of K3S. I was about to learn this was actually a lot harder than I imagined it would be.</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#windmill-in-pikvm-host-os","title":"Windmill in PiKVM Host OS","text":"<p>PiKVM is based on Arch Linux, which supports K3s. The only notable difference? Its read-only filesystem! Let\u2019s change that.</p> Steps <ol> <li>Circumvent read-only file system as described here. (Tip: Look for instructions between the giant warning banners \ud83d\ude02). </li> <li>Install K3s</li> <li>Setup helmfile with the Windmill chart</li> <li>Run <code>helmfile apply</code></li> <li>Watch it fail \ud83e\udd26\u200d\u2642\ufe0f</li> </ol> Result <p>I was surprised it took a really long time to start the Windmill pods. Checking out the kubectl logs I came to the realisation that k3s was unable to pull an image from the registry due to a mismatch in architecture. The Windmill package only supports <code>arm64</code>, while PiKVM runs on <code>armhf</code>.</p> <p>Lesson 1</p> <p>Do your due diligence! Arm64 and armhf are different architectures, and software compatibility isn\u2019t guaranteed.</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#pikvm-in-esxi-arm-fling-vm","title":"PiKVM in ESXi-Arm Fling VM","text":"<p>PiKVM doesn\u2019t offer a 64-bit version of the OS (source, source), yet I needed to run 64-bit and 32-bit software on the same machine. Enter ESXi-Arm Fling. Success guaranteed of course, as ESXi is built and maintained by a reputable company.</p> Steps <ol> <li>Create an account on the Broadcom website and download the documentation</li> <li> <p>From the documentation</p> <ol> <li>Update Raspberry Pi 4 EEPROM</li> <li>Flash UEFI to sdcard from https://github.com/pftf/RPi4/releases</li> <li> <p>Make OSData partition 25gb by passing this in the boot screen (to not have ESXi take all the space in the thumb-drive)</p> <pre><code>systemMediaSize=min\n</code></pre> </li> <li> <p>When asked for a ESX OSData store when installing on a USB attached disk press enter to skip this, otherwise you\u2019ll get a cryptic error and have to start over.</p> </li> <li>Get license code from this gist who is kind enough to share it with the rest of the world.</li> <li>Add license code to ESXi</li> <li>Download official PiKVM v3 image</li> <li>Convert the image to vmdk</li> </ol> <pre><code>qemu-img convert -f raw -O vmdk ~/Downloads/v3-hdmi-rpi4-box-latest.img ~/Downloads/v3-hdmi-rpi4-box-latest.vmdk\n</code></pre> </li> <li> <p>Upload <code>v3-hdmi-rpi4-box-latest.vmdk</code></p> </li> <li>Configure the <code>pikvm</code> virtual machine </li> <li>Attach the uploaded disk to the virtual machine</li> <li>Boot the machine</li> <li>Watch if fail \ud83e\udd26\u200d\u2642\ufe0f</li> </ol> Result <p>The VM wouldn\u2019t boot\u2014a 32-bit PiKVM image can\u2019t run as a 64-bit VM. I also tried to run the virtual machine with the Debian net installer: https://cdimage.debian.org/debian-cd/current/arm64/iso-cd/ and trying add grub to the root file system, but with no success.</p> <p>Lesson 2</p> <p>Details matter! Not all OS images work with hypervisors. The Pi has a unique boot process.</p> <p>Lesson 3</p> <p>Temper expectations with early-access software. ESXi-Arm Fling doesn\u2019t support 32-bit arm VMs (source, source).</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#pikvm-in-pimox-vm","title":"PiKVM in Pimox VM","text":"<p>Pimox (Proxmox + Pi) seemed promising based on this Reddit post with support for 32-bit VMs.</p> Steps <ol> <li>Install Pimox (source, source, source, source, source)</li> <li>Create and run an Ansible Playbook (see pull request)</li> <li>Initialise a Proxmox VM</li> <li>Search for the device passthrough section to passthrough the following devices:<ol> <li>OTG port for keyboard/mouse/mass storage device (msd) emulation on the target the PiKVM is attached to</li> <li>HDMI capture card and hardware H264 encoding for streaming target video output</li> <li>GPIO for ATX control for power on/off control</li> <li>I2C for the OLED screen</li> </ol> </li> <li>Fail \ud83e\udd26\u200d\u2642\ufe0f</li> </ol> Result <p>Hypervisors like Proxmox can\u2019t easily passthrough all devices from host to guest. I did some reading about vfio passthrough but that was waaaay out of my comfort zone, so I decided to give up on running PiKVM inside a vm.</p> <p>Thanks for helping me set up PiKVM in a vm @srepac!</p> <p>Lesson 4</p> <p>Tackle highest risk first. Device passthrough in VMs is complex. Not all devices can be passed to guests.</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#kvmd-armbian-in-pimox-host-os","title":"Kvmd-armbian in Pimox Host OS","text":"<p>Suffering from sunk cost fallacy big time I kept pursuing my goal. Determined I found kvmd-armbian which is an unofficial port that supports 32-bit, 64-bit on arm AND x86 machines. Bonus points having a Discord channel for support.</p> Steps <ol> <li>Install Pimox</li> <li>Create and run an Ansible Playbook</li> <li>Run installer from kvmd-armbian</li> <li> <p>Disable the Pimox firewall to get access to the kvmd web ui (Tip: Please enable it again if you plan deploy like this \ud83d\ude05)</p> <pre><code>pve-firewall stop\n</code></pre> </li> <li> <p>Fix OLED screen for kvmd-armbian</p> </li> <li>Celebrate \ud83c\udf89</li> </ol> Result <p>With help from the kvmd-armbian community \u2764\ufe0f it worked, but running two unofficial setups (Pimox + kvmd-armbian) in the host OS felt unsustainable. If one of the projects would stop developing I\u2019d have to start over.</p> <p>Lesson 5</p> <p>Prioritize long-term maintainability.</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#kvmd-armbian-in-pimox-lxc","title":"Kvmd-armbian in Pimox LXC","text":"<p>If I can\u2019t run kvmd-armbian on the host and not in a VM, what are my options? I looked into docker containers and LXC containers. As LXC is closer to a vm than Docker and PiKVM has specific host requirements like an additional partition for msd, I decided to go with LXC.</p> Steps <ol> <li>Download LXC Jammy and create a container template (source)</li> <li>Create an LXC container with the following settings<ol> <li>Hostname: pikvm</li> <li>UNCHECK - unprivileged container (so privileged container)</li> <li>Password: Password1234 (Tip: don\u2019t)</li> </ol> </li> <li>Start the LXC container and attach the console</li> <li>Run kvmd-installer</li> <li>Fix OLED screen for kvmd-armbian</li> <li>Forward devices from host to guest (I have to admit this was pretty time consuming \ud83d\ude05)<ol> <li>Passthrough GPIO for ATX control</li> <li>Passthrough OTG port for keyboard/mouse</li> <li>Passthrough OTG port for keyboard/mouse</li> <li>Passthrough HDMI capture card</li> <li>Passthrough I2C for the OLED screen</li> </ol> </li> <li>Celebrate \ud83c\udf89</li> </ol> Result <p>This separation enabled easier updates for both host and guest OS, leaving me less worried about potential future breakage.</p> <p>Lesson 6</p> <p>Ask for help! LXC and device passthrough are pretty far out of my comfort zone, I used ChatGPT which was incredibly helpful!</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#kvmd-armbian-in-incus-lxc","title":"Kvmd-armbian in Incus LXC","text":"<p>Next I decided to see if it\u2019s possible to use a hypervisor which is officially supported on arm AND supports LXC out of the box. I investigated the following, not an exhaustive list:</p> Hypervisor Raspberry Pi 4 support LXC support ESXI Arm Fling \u2705 \u274c Proxmox \u2705: Using unofficial Pimox port \u2705 xcp ng \u274c: Work in progress \u274c: Abandoned initiative RunX Cloud hypervisor \u2705 \u274c Incus \u2705 \u2705 <p>The choice landed on Incus (see pull request).</p> Steps <ol> <li>Using Raspberry Pi Imager:<ol> <li>OS: Ubuntu Server 24.04 LTS 64-bit</li> <li>Username: deploy</li> <li>Hostname: provisioner</li> <li>Password: <code>Password1234</code></li> </ol> </li> <li> <p>Setup Incus host using Ansible playbook</p> <pre><code>ansible-playbook -i ./production.local provisioner.yml --diff\n</code></pre> </li> <li> <p>Create Incus kvmd-armbian LXC container with passthrough</p> </li> <li> <p>Start the LXC container</p> <pre><code>incus start kvmd\n</code></pre> </li> <li> <p>Run the kvmd-armbian installer</p> </li> <li>Fix OLED screen for kvmd-armbian</li> <li> <p>Restart the container</p> <pre><code>incus restart kvmd\n</code></pre> </li> <li> <p>Celebrate \ud83c\udf89</p> </li> </ol> Result <p>A clean, supported hypervisor setup (many kudos to the Incus team \ud83d\udc4f). At this point I\u2019m pretty happy. But having spent all this time, it would be a waste not to spend EVEN MORE time trying to improve things.</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#pikvm-in-incus-lxc","title":"PiKVM in Incus LXC","text":"<p>Inspired by pikvm-container, a (dated) implementation of running PiKVM inside a docker container, I adapted the official PiKVM image for LXC (see pull request with Packer pipeline).</p> Steps <ol> <li>Download official PiKVM v3 image</li> <li>Extract partitions using 7zip</li> <li> <p>Loop mount partitions</p> <pre><code>mkdir -p /mnt/rootfs\nmkdir -p /mnt/rootfs/boot\nmount -o loop 2.img /mnt/rootfs\nmount -o loop 0.fat /mnt/rootfs/boot\n</code></pre> </li> <li> <p>Use distrobuilder to convert<code>/mnt/rootfs</code> into an Incus LXC image with modifications</p> <ol> <li>Remove <code>/etc/fstab</code></li> <li>Disable msd</li> <li>Add a systemd boot service to generate certificates</li> <li>Mask service <code>kvmd-pst</code>, <code>kvmd-fan</code>, <code>kvmd-watchdog</code> and <code>kvmd-bootconfig</code> because PiKVM works without those (and I don\u2019t want to spend more time fixing those services \ud83d\ude02)</li> </ol> </li> <li> <p>Import the image into Incus</p> <pre><code>incus image import pikvm-rpi4.tar.xz --alias pikvm-rpi4/latest\n</code></pre> </li> <li> <p>Create Incus PiKVM LXC container with passthrough</p> </li> <li> <p>Check the console for errors</p> <pre><code>incus console pikvm --show-log\n</code></pre> </li> <li> <p>Celebrate \ud83c\udf89</p> </li> </ol> Result <p>Success! I\u2019m running an officially supported hypervisor and a hacky-officially supported installation of PiKVM inside an LXC container! Now I can get back to what I was doing, spinning up Windmill.</p> <p>Lesson 7</p> <p>The on holder wins \ud83c\uddf3\ud83c\uddf1 (in regular English: Persistence pays off)</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#closing-thoughts","title":"Closing Thoughts","text":"<p>Thanks to the kvmd-armbian community, Google, Reddit, and ChatGPT, I\u2019ve gained invaluable insights into the Raspberry Pi, hypervisors, and device passthrough. Would I recommend this journey? Probably not\u2014just get a second Pi for PiKVM. But where\u2019s the fun in that? \ud83d\ude06</p>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#code-snippets","title":"Code Snippets","text":"","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#fix-oled-screen-for-kvmd-armbian","title":"Fix OLED Screen for Kvmd-armbian","text":"<p>Copied from Discord comment</p> <pre><code>apt-get install -y python3-usb python3-luma.core python3-luma.lcd python3-luma.oled\n\nmkdir -p /usr/share/fonts/TTF\ncurl -L https://github.com/pikvm/kvmd/raw/ebda7ea03d178ebf93f115eaa75cf059e010cd96/kvmd/apps/oled/fonts/ProggySquare.ttf --output /usr/share/fonts/TTF/ProggySquare.ttf\n\ncurl -L https://kvmnerds.com/REPO/NEW/kvmd-oled-0.26-1-any.pkg.tar.xz --output /tmp/kvmd-oled-0.26-1-any.pkg.tar.xz\ncd /\ntar xfJ /tmp/kvmd-oled-0.26-1-any.pkg.tar.xz\n\nsystemctl enable /usr/lib/systemd/system/kvmd-oled-reboot.service\nsystemctl enable /usr/lib/systemd/system/kvmd-oled.service\nsystemctl enable /usr/lib/systemd/system/kvmd-oled-shutdown.service\n</code></pre>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#passthrough-gpio-for-atx-control","title":"Passthrough GPIO for ATX Control","text":"<ol> <li> <p>I used the output of <code>journalctl -f</code> to figure out where kvmd-armbian would break:</p> <pre><code>Dec 29 19:36:40 pikvm kvmd[602]: File \"/usr/bin/kvmd\", line 8, in &lt;module&gt;\nDec 29 19:36:40 pikvm kvmd[602]: sys.exit(main())\nDec 29 19:36:40 pikvm kvmd[602]: File \"/usr/lib/python3/dist-packages/kvmd/apps/kvmd/__init__.py\", line 75, in main\nDec 29 19:36:40 pikvm kvmd[602]: KvmdServer(\nDec 29 19:36:40 pikvm kvmd[602]: File \"/usr/lib/python3/dist-packages/kvmd/apps/kvmd/server.py\", line 263, in run\nDec 29 19:36:40 pikvm kvmd[602]: comp.sysprep()\nDec 29 19:36:40 pikvm kvmd[602]: File \"/usr/lib/python3/dist-packages/kvmd/apps/kvmd/ugpio.py\", line 294, in sysprep\nDec 29 19:36:40 pikvm kvmd[602]: driver.prepare()\nDec 29 19:36:40 pikvm kvmd[602]: File \"/usr/lib/python3/dist-packages/kvmd/plugins/ugpio/gpio.py\", line 86, in prepare\nDec 29 19:36:40 pikvm kvmd[602]: self.__chip = gpiod.Chip(self.__device_path) Dec 29 19:36:40 pikvm kvmd[602]: PermissionError: [Errno 1] Operation not permitted\n</code></pre> </li> <li> <p>Running <code>kvmd -m</code> showed me what gpio device what was spected</p> <pre><code>kvmd:\n atx:\n   device: /dev/gpiochip0\n</code></pre> </li> <li> <p>Update the LXC template</p> <pre><code># 254 is the major number as can be seen by the ls command OR stat /dev/gpiochip0\nlxc.cgroup2.devices.allow = c 254:* rwm\nlxc.mount.entry = /dev/gpiochip0 dev/gpiochip0 none bind,optional,create=file\n</code></pre> </li> <li> <p>Restart the LXC using the UI</p> </li> <li>Works!</li> </ol>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#passthrough-otg-port-for-keyboardmouse","title":"Passthrough OTG Port for keyboard/mouse","text":"<ol> <li> <p>Failure from <code>journalctl</code></p> <pre><code>Dec 30 04:52:47 pikvm systemd[1]: Starting PiKVM - OTG setup...\nDec 30 04:52:48 pikvm kvmd-otg[182]: kvmd.apps.otg                     INFO --- Using UDC fe980000.usb\nDec 30 04:52:48 pikvm kvmd-otg[182]: kvmd.apps.otg                     INFO --- Creating gadget 'kvmd' ...\nDec 30 04:52:48 pikvm kvmd-otg[182]: kvmd.apps.otg                     INFO --- MKDIR --- /sys/kernel/config/usb_gadget/kvmd\nDec 30 04:52:48 pikvm kvmd-otg[182]: Traceback (most recent call last):\nDec 30 04:52:48 pikvm kvmd-otg[182]:   File \"/usr/bin/kvmd-otg\", line 8, in &lt;module&gt;\nDec 30 04:52:48 pikvm kvmd-otg[182]:     sys.exit(main())\nDec 30 04:52:48 pikvm kvmd-otg[182]:   File \"/usr/lib/python3/dist-packages/kvmd/apps/otg/__init__.py\", line 348, in main\nDec 30 04:52:48 pikvm kvmd-otg[182]:     options.cmd(config)\nDec 30 04:52:48 pikvm kvmd-otg[182]:   File \"/usr/lib/python3/dist-packages/kvmd/apps/otg/__init__.py\", line 212, in _cmd_start\nDec 30 04:52:48 pikvm kvmd-otg[182]:     _mkdir(gadget_path)\nDec 30 04:52:48 pikvm kvmd-otg[182]:   File \"/usr/lib/python3/dist-packages/kvmd/apps/otg/__init__.py\", line 50, in _mkdir\nDec 30 04:52:48 pikvm kvmd-otg[182]:     os.mkdir(path)\nDec 30 04:52:48 pikvm kvmd-otg[182]: FileNotFoundError: [Errno 2] No such file or directory: '/sys/kernel/config/usb_gadget/kvmd'\n</code></pre> </li> <li> <p>Check which devices are expected from <code>kvmd -m</code></p> <pre><code>hid:\n keyboard:\n   device: /dev/kvmd-hid-keyboard\n\n mouse:\n   device: /dev/kvmd-hid-mouse\n\n mouse_alt:\n   device: /dev/kvmd-hid-mouse-alt\n</code></pre> </li> <li> <p>Ensure kernel module in the host <code>i2c-dev</code> is loaded</p> </li> <li> <p>Mount <code>/sys/kernel/config</code> in LXC by updating the template</p> <pre><code>lxc.mount.entry: /sys/kernel/config sys/kernel/config none bind,optional\n# 236 is the major group of the hidg* devices\nlxc.cgroup2.devices.allow: c 236:* rwm\n</code></pre> </li> <li> <p>Once the <code>kvmd-otg</code> service starts the usb_gadget devices are created in the host, not in the guest</p> <pre><code>crw-rw----  1 root kvmd    236,   0 Dec 30 15:52 hidg0\ncrw-rw----  1 root kvmd    236,   1 Dec 30 15:52 hidg1\ncrw-rw----  1 root kvmd    236,   2 Dec 30 15:52 hidg2\n</code></pre> </li> <li> <p>Now it\u2019s a bit of a \ud83d\udc14 and \ud83e\udd5a situation, where we need the <code>/dev/hidg*</code> devices to exist on the host before starting the container. But once the container starts these devices are created on the host \ud83d\ude05. Therefore inside the LXC we need to add these devices manually</p> <pre><code>mknod /dev/kvmd-hid-keyboard c 236 0\nmknod /dev/kvmd-hid-mouse c 236 1\nmknod /dev/kvmd-hid-mouse-alt c 236 2\n</code></pre> </li> <li> <p>Ensure the permissions on these devices are correct so the kvmd group can control them</p> <pre><code>chown root:kvmd /dev/kvmd-hid-keyboard /dev/kvmd-hid-mouse /dev/kvmd-hid-mouse-alt\nchmod 0660  /dev/kvmd-hid-keyboard /dev/kvmd-hid-mouse /dev/kvmd-hid-mouse-alt\n</code></pre> </li> <li> <p>Login to the web UI validate that the keyboard works! (Note the kvmd is attached to a server, so unable to test the mouse)</p> </li> </ol>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#passthrough-hdmi-capture-card","title":"Passthrough HDMI Capture Card","text":"<ol> <li> <p>Failure from <code>journalctl</code></p> <pre><code>Dec 30 05:03:41 pikvm systemd[1]: Starting PiKVM - EDID loader for TC358743...\nDec 30 05:03:41 pikvm v4l2-ctl[182]: Cannot open device /dev/kvmd-video, exiting.\nDec 30 05:03:41 pikvm systemd[1]: kvmd-tc358743.service: Main process exited, code=exited, status=1/FAILURE\nDec 30 05:03:41 pikvm systemd[1]: kvmd-tc358743.service: Failed with result 'exit-code'.\nDec 30 05:03:41 pikvm systemd[1]: Failed to start PiKVM - EDID loader for TC358743.\n</code></pre> </li> <li> <p>The error message mentions the relevant device!</p> </li> <li> <p>Update the LXC template</p> <pre><code>lxc.cgroup2.devices.allow: c 81:* rwm\nlxc.mount.entry: /dev/video0 dev/kvmd-video none bind,optional,create=file\n</code></pre> </li> <li> <p>Restart the LXC</p> </li> <li> <p>Now we see a different error</p> <pre><code>Dec 30 05:32:21 pikvm kvmd[237]: kvmd.apps.kvmd.streamer           INFO --- =&gt; -- ERROR [36989.079          ] -- H264: Can t open encoder device: No such file or directory\nDec 30 05:32:21 pikvm kvmd[237]: kvmd.apps.kvmd.streamer           INFO --- =&gt; -- ERROR [36989.079          ] -- H264: Encoder destroyed due an error (prepare)\n</code></pre> </li> <li> <p>This is because the H264 encoder is a separate video device on the Raspberry Pi. I decided to simply passthrough all video devices, but there is probably a smarter way to go about this \ud83d\ude48</p> <pre><code>lxc.cgroup2.devices.allow: c 81:* rwm\nlxc.mount.entry: /dev/video0  dev/kvmd-video none bind,optional,create=file\nlxc.mount.entry: /dev/video10 dev/video10 none bind,optional,create=file\nlxc.mount.entry: /dev/video11 dev/video11 none bind,optional,create=file\nlxc.mount.entry: /dev/video12 dev/video12 none bind,optional,create=file\nlxc.mount.entry: /dev/video13 dev/video13 none bind,optional,create=file\nlxc.mount.entry: /dev/video14 dev/video14 none bind,optional,create=file\nlxc.mount.entry: /dev/video15 dev/video15 none bind,optional,create=file\nlxc.mount.entry: /dev/video16 dev/video16 none bind,optional,create=file\nlxc.mount.entry: /dev/video18 dev/video18 none bind,optional,create=file\nlxc.mount.entry: /dev/video19 dev/video19 none bind,optional,create=file\nlxc.mount.entry: /dev/video20 dev/video20 none bind,optional,create=file\nlxc.mount.entry: /dev/video21 dev/video21 none bind,optional,create=file\nlxc.mount.entry: /dev/video22 dev/video22 none bind,optional,create=file\nlxc.mount.entry: /dev/video23 dev/video23 none bind,optional,create=file\nlxc.mount.entry: /dev/video31 dev/video31 none bind,optional,create=file\n</code></pre> </li> <li> <p>Restart the LXC</p> </li> <li>Navigate to the web UI and validate it works \ud83c\udf89</li> </ol>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#passthrough-i2c-for-the-oled-screen","title":"Passthrough I2C for the OLED Screen","text":"<ol> <li><code>journalctl</code> and <code>systemctl</code> didn\u2019t show the <code>kvmd-oled</code> service</li> <li> <p>Running <code>systemctl start kvmd-oled</code> showed the problem, the device <code>/dev/i2c-1</code> didn\u2019t exist</p> <pre><code>Jan 08 09:14:13 pikvm systemd[1]: PiKVM - A small OLED daemon was skipped because of an unmet condition check (ConditionPathExists=/dev/i2c-1).\n</code></pre> </li> <li> <p>Easy peasy \ud83c\udf4b! Update the LXC template</p> <pre><code>lxc.cgroup2.devices.allow: c 89:* rwm\nlxc.mount.entry: /dev/i2c-1 dev/i2c-1 none bind,optional,create=file 0 0\n</code></pre> </li> <li> <p>Restart the LXC</p> </li> <li>BOOM </li> </ol>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#incus-kvmd-armbian-lxc-container-with-passthrough","title":"Incus Kvmd-armbian LXC Container with Passthrough","text":"<pre><code># create pikvm container using ubuntu/jammy as the base as mentioned in the kvmd-armbian repository\nincus init images:ubuntu/jammy kvmd\n\n# Passthrough all the video devices for hdmi video capture and hardware decoing of H264. Using uid/gid 999 here as that's the id of kvmd inside the LXC container.\nincus config device add kvmd kvmd-video unix-char  path=/dev/kvmd-video source=/dev/video0   required=true gid=999 uid=999\nincus config device add kvmd video10 unix-char path=/dev/video10 source=/dev/video10 required=true gid=999 uid=999\nincus config device add kvmd video11 unix-char path=/dev/video11 source=/dev/video11 required=true gid=999 uid=999\nincus config device add kvmd video12 unix-char path=/dev/video12 source=/dev/video12 required=true gid=999 uid=999\nincus config device add kvmd video13 unix-char path=/dev/video13 source=/dev/video13 required=true gid=999 uid=999\nincus config device add kvmd video14 unix-char path=/dev/video14 source=/dev/video14 required=true gid=999 uid=999\nincus config device add kvmd video15 unix-char path=/dev/video15 source=/dev/video15 required=true gid=999 uid=999\nincus config device add kvmd video16 unix-char path=/dev/video16 source=/dev/video16 required=true gid=999 uid=999\nincus config device add kvmd video18 unix-char path=/dev/video18 source=/dev/video18 required=true gid=999 uid=999\nincus config device add kvmd video19 unix-char path=/dev/video19 source=/dev/video19 required=true gid=999 uid=999\nincus config device add kvmd video20 unix-char path=/dev/video20 source=/dev/video20 required=true gid=999 uid=999\nincus config device add kvmd video21 unix-char path=/dev/video21 source=/dev/video21 required=true gid=999 uid=999\nincus config device add kvmd video22 unix-char path=/dev/video22 source=/dev/video22 required=true gid=999 uid=999\nincus config device add kvmd video23 unix-char path=/dev/video23 source=/dev/video23 required=true gid=999 uid=999\nincus config device add kvmd video31 unix-char path=/dev/video31 source=/dev/video31 required=true gid=999 uid=999\n\n# Passthrough the gpiochip0 to enable ATX control\nincus config device add kvmd gpiochip0 unix-char path=/dev/gpiochip0 source=/dev/gpiochip0 required=true gid=999 uid=999\n\n# Make sure to disable apparmor so we get read/write access to sys\nincus config set kvmd raw.lxc \"lxc.apparmor.profile=unconfined\"\n\n# Add the /sys/kernel/config directory as a mount to enable the guest to create usb devices in the host to enable otg based keyboard/mouse emulation.\nincus config device add kvmd sys-kernel disk source=/sys/kernel/config path=/sys/kernel/config required=true\n\n# We passthrough the hidgX devices from the host to the guest when they appear. The guest first needs to boot and create the usb_gadget devices before the /dev/hidgX devices appear in the host therefore the devices are marked as \"required=false\". Once the device appears it's hotplugged and added to the guest.\n# See https://linuxcontainers.org/incus/docs/main/reference/devices_unix_char/\nincus config device add kvmd hidg0 unix-char path=/dev/kvmd-hid-keyboard source=/dev/hidg0 required=false gid=999 uid=999\nincus config device add kvmd hidg1 unix-char path=/dev/kvmd-hid-mouse source=/dev/hidg1 required=false gid=999 uid=999\nincus config device add kvmd hidg2 unix-char path=/dev/kvmd-hid-mouse-alt source=/dev/hidg2 required=false gid=999 uid=999\n\n# We passthrough the i2c-1 device to enable access to the OLED device\nincus config device add kvmd i2c-1 unix-char path=/dev/i2c-1 source=/dev/i2c-1 required=true gid=999 uid=999\n</code></pre>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"blog/lessons-learned-deploying-pikvm/#incus-pikvm-lxc-container-with-passthrough","title":"Incus PiKVM LXC Container with Passthrough","text":"<pre><code>incus init provisioner:pikvm-rpi4/latest pikvm\n\n# Make sure to disable apparmor and enable privileged container so we get read/write access to sys\nincus config set pikvm raw.lxc \"lxc.apparmor.profile=unconfined\"\nincus config set pikvm security.privileged true\n\n# boot the instance at startup\nincus config set pikvm boot.autorestart true\nincus config set pikvm boot.autostart true\n\n# Passthrough all the video devices for hdmi video capture and hardware decoing of H264\n# Note I'm using gid/uid 968 instead of 999 because the user and group ids of kvmd are different in the official image!\nincus config device add pikvm kvmd-video unix-char path=/dev/kvmd-video source=/dev/video0  required=true gid=968 uid=968\nincus config device add pikvm video10    unix-char path=/dev/video10    source=/dev/video10 required=true gid=968 uid=968\nincus config device add pikvm video11    unix-char path=/dev/video11    source=/dev/video11 required=true gid=968 uid=968\nincus config device add pikvm video12    unix-char path=/dev/video12    source=/dev/video12 required=true gid=968 uid=968\nincus config device add pikvm video13    unix-char path=/dev/video13    source=/dev/video13 required=true gid=968 uid=968\nincus config device add pikvm video14    unix-char path=/dev/video14    source=/dev/video14 required=true gid=968 uid=968\nincus config device add pikvm video15    unix-char path=/dev/video15    source=/dev/video15 required=true gid=968 uid=968\nincus config device add pikvm video16    unix-char path=/dev/video16    source=/dev/video16 required=true gid=968 uid=968\nincus config device add pikvm video18    unix-char path=/dev/video18    source=/dev/video18 required=true gid=968 uid=968\nincus config device add pikvm video19    unix-char path=/dev/video19    source=/dev/video19 required=true gid=968 uid=968\nincus config device add pikvm video20    unix-char path=/dev/video20    source=/dev/video20 required=true gid=968 uid=968\nincus config device add pikvm video21    unix-char path=/dev/video21    source=/dev/video21 required=true gid=968 uid=968\nincus config device add pikvm video22    unix-char path=/dev/video22    source=/dev/video22 required=true gid=968 uid=968\nincus config device add pikvm video23    unix-char path=/dev/video23    source=/dev/video23 required=true gid=968 uid=968\nincus config device add pikvm video31    unix-char path=/dev/video31    source=/dev/video31 required=true gid=968 uid=968\nincus config device add pikvm vcio    unix-char path=/dev/vcio    source=/dev/vcio required=true gid=968 uid=968\n\n\n# Passthrough the gpiochip0 to enable ATX control\nincus config device add pikvm gpiochip0 unix-char path=/dev/gpiochip0 source=/dev/gpiochip0 required=true gid=968 uid=968\n\n# Add the /sys/kernel/config directory as a mount to enable the guest to create usb devices in the host to enable otg based keyboard/mouse emulation.\nincus config device add pikvm sys-kernel disk source=/sys/kernel/config path=/sys/kernel/config required=true\n\n# We passthrough the hidgX devices from the host to the guest when they appear. The guest first needs to boot and create the usb_gadget devices before the /dev/hidgX devices appear in the host therefore the devices are marked as \"required=false\". Once the device appears it's hotplugged and added to the guest.\n# See https://linuxcontainers.org/incus/docs/main/reference/devices_unix_char/\nincus config device add pikvm hidg0 unix-char path=/dev/kvmd-hid-keyboard  source=/dev/hidg0 required=false gid=968 uid=968\nincus config device add pikvm hidg1 unix-char path=/dev/kvmd-hid-mouse     source=/dev/hidg1 required=false gid=968 uid=968\nincus config device add pikvm hidg2 unix-char path=/dev/kvmd-hid-mouse-alt source=/dev/hidg2 required=false gid=968 uid=968\n\n# We passthrough the i2c-1 device to enable access to the OLED device\nincus config device add pikvm i2c-1 unix-char path=/dev/i2c-1 source=/dev/i2c-1 required=true gid=968 uid=968\n\nincus start pikvm\n</code></pre>","tags":["lxc","pikvm","incus","ansible","packer"]},{"location":"internal/bootstrap-provisioner-k8s/","title":"Bootstrap provisioner-k8s","text":"<ol> <li> <p>Create Incus instance</p> <pre><code># Create Incus VM (not container)\nincus create images:ubuntu/24.04 provisioner-k8s --vm\n\n# Set max memory to 7GiB\nincus config set provisioner-k8s limits.memory 7GiB\n\n# Set cpu cores to 4\nincus config set provisioner-k8s limits.cpu 4\n\n# Set storage to 50GiB\nincus config device override provisioner-k8s root size=50GiB\n\n# Start!\nincus start provisioner-k8s\n</code></pre> </li> <li> <p>Run Ansible playbook with local inventory</p> <pre><code>```bash\ntask provisioner-k8s:provision:local\n```\n</code></pre> </li> <li> <p>Validate if host can now be provisioned through Tailscale</p> <pre><code>task provisioner-k8s:provision\n</code></pre> </li> <li> <p>Copy Kubernetes secret <code>/etc/rancher/k3s/k3s.yaml</code> into 1Password <code>op://vgijssel-prod/provisioner-k8s-kubeconfig/certificate</code></p> </li> <li>Modify server url to <code>https://provisioner-k8s.tail2c33e2.ts.net:6443</code></li> <li> <p>Update devenv secrets</p> <pre><code>task devenv:secrets\n</code></pre> </li> </ol>"}]}