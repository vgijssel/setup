substitutions:
  device_name: "office-shelly"
  entity_id: "office_shelly"

packages:
  device_base: !include .shelly-1pm-plus.yaml
  base: !include .base.yaml

binary_sensor:
  - <<: !include .basic_light_binary_sensor.yaml
    name: ${entity_id}_input
    pin: GPIO4

# globals:
#   - id: room_topic
#     type: std::string
#     initial_value: '"room_presence/${entity_id}"'

# TODO: misconfiguration in mqtt results in wifi no longer working!
mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: false # Only if you use the HA API usually
  id: mqtt_client

# esp32_ble_tracker:
#   scan_parameters:
#     interval: 1.2s
#     window: 500ms
#     active: false
#   on_ble_advertise:
#     - then:
#       # Look for manufacturer data of form: 4c00 10 05 YY 98 XXXXXX
#       # Where YY can be 01..0F or 20..2F; and XXXXXX is ignored
#       - lambda: |-
#           optional<int16_t> best_rssi = nullopt;

#           for (auto data : x.get_manufacturer_datas()) {
#             // Guard against non-Apple datagrams, or those that are too small.
#             if (data.data.size() < 4 || data.uuid.to_string() != "0x004C" || data.data[0] != 0x10 || data.data[1] < 5) {
#               continue;
#             }
#             const int16_t rssi = x.get_rssi();
#             const uint8_t status_flags = data.data[2] >> 4;  // High nibble
#             const uint8_t data_flags = data.data[3];

#             if (data_flags == 0x98) {  // Match unlocked Apple Watch. To also match locked watch use: if (data_flags == 0x98 || data_flags == 0x18) {
#               if (status_flags == 0 || status_flags == 2) {
#                 best_rssi = max(rssi, best_rssi.value_or(rssi));
#                 ESP_LOGD("ble_adv", "Found Apple Watch (mac %s) rssi %i", x.address_str().c_str(), rssi);
#               } else {
#                 ESP_LOGD("ble_adv", "Possible Apple Watch? (mac %s) rssi %i, unrecognised status/action flags %#04x", x.address_str().c_str(), rssi, data.data[2]);
#               }
#             }
#           }
#           if (best_rssi) {
#             id(apple_watch_rssi).publish_state(*best_rssi);
#           }

# ble_client:
#   - mac_address: 74:F3:1B:10:43:46 

# [20:52:17][I][ble_client:171]: Service UUID: 0x1800
# [20:52:17][I][ble_client:172]:   start_handle: 0x1  end_handle: 0x5
# [20:52:17][I][ble_client:384]:  characteristic 0x2A00, handle 0x3, properties 0x2
# [20:52:17][I][ble_client:384]:  characteristic 0x2A01, handle 0x5, properties 0x2
# [20:52:17][I][ble_client:171]: Service UUID: 0x180A
# [20:52:17][I][ble_client:172]:   start_handle: 0x6  end_handle: 0xa
# [20:52:17][I][ble_client:384]:  characteristic 0x2A29, handle 0x8, properties 0x2
# [20:52:17][I][ble_client:384]:  characteristic 0x2A24, handle 0xa, properties 0x2
# [20:52:17][I][ble_client:171]: Service UUID: 0x1801
# [20:52:17][I][ble_client:172]:   start_handle: 0xb  end_handle: 0xe
# [20:52:17][I][ble_client:384]:  characteristic 0x2A05, handle 0xd, properties 0x20
# [20:52:17][I][ble_client:171]: Service UUID: D0611E78-BBB4-4591-A5F8-487910AE4366
# [20:52:17][I][ble_client:172]:   start_handle: 0xf  end_handle: 0x13
# [20:52:17][I][ble_client:384]:  characteristic 8667556C-9A37-4C91-84ED-54EE27D90049, handle 0x11, properties 0x98
# [20:52:17][I][ble_client:171]: Service UUID: 9FA480E0-4967-4542-9390-D343DC5D04AE
# [20:52:17][I][ble_client:172]:   start_handle: 0x14  end_handle: 0x18
# [20:52:17][I][ble_client:384]:  characteristic AF0BADB1-5B99-43CD-917A-A77BC549E3CC, handle 0x16, properties 0x98

# [08:45:30][I][ble_sensor:031]: [device_name] Connected successfully!
# [08:45:31][I][ble_client:171]: Service UUID: 0x1800
# [08:45:31][I][ble_client:172]:   start_handle: 0x1  end_handle: 0x5
# [08:45:31][I][ble_client:384]:  characteristic 0x2A00, handle 0x3, properties 0x2
# [08:45:31][I][ble_client:384]:  characteristic 0x2A01, handle 0x5, properties 0x2
# [08:45:31][I][ble_client:171]: Service UUID: 0x180A
# [08:45:31][I][ble_client:172]:   start_handle: 0x6  end_handle: 0xa
# [08:45:31][I][ble_client:384]:  characteristic 0x2A29, handle 0x8, properties 0x2
# [08:45:31][I][ble_client:384]:  characteristic 0x2A24, handle 0xa, properties 0x2
# [08:45:31][I][ble_client:171]: Service UUID: 0x1801
# [08:45:31][I][ble_client:172]:   start_handle: 0xb  end_handle: 0xe
# [08:45:32][I][ble_client:384]:  characteristic 0x2A05, handle 0xd, properties 0x20
# [08:45:32][I][ble_client:171]: Service UUID: D0611E78-BBB4-4591-A5F8-487910AE4366
# [08:45:32][I][ble_client:172]:   start_handle: 0xf  end_handle: 0x13
# [08:45:32][I][ble_client:384]:  characteristic 8667556C-9A37-4C91-84ED-54EE27D90049, handle 0x11, properties 0x98
# [08:45:32][I][ble_client:171]: Service UUID: 9FA480E0-4967-4542-9390-D343DC5D04AE
# [08:45:32][I][ble_client:172]:   start_handle: 0x14  end_handle: 0x18
# [08:45:32][I][ble_client:384]:  characteristic AF0BADB1-5B99-43CD-917A-A77BC549E3CC, handle 0x16, properties 0x98

# Service UUID: 0x1800
# 0x2A00: Device Name - Apple Watch
# 0x2A01: Appearance - ???

# Service UUID: 0x180A
# 0x2A29: Manufacturer Name String - ???
# 0x2A24: Model Number String - ???

# Service UUID: 0x1801
# 0x2A05: Service Changed - ???

ble_client:
  - mac_address: 4C:79:1F:E6:7B:8F
    id: apple_watch

text_sensor:
  - platform: template
    name: "Apple Watch Name"
    id: apple_watch_sensor_name

  - platform: template
    name: "Something Else"
    id: something_else_sensor

# From https://koen.vervloesem.eu/blog/connecting-to-bluetooth-low-energy-devices-in-esphome/
sensor:
  # results in "Apple Watch"
  - platform: ble_client
    ble_client_id: apple_watch
    id: device_name
    service_uuid: '1800' # # Generic Access Profile
    characteristic_uuid: '2a00' # Device Name
    lambda: |-
      std::string data_string(x.begin(), x.end());
      id(apple_watch_sensor_name).publish_state(data_string.c_str());
      return (float)x.size();
  - platform: ble_client
    ble_client_id: apple_watch
    id: something_else
    service_uuid: '1800' # # Generic Access Profile
    characteristic_uuid: '2a01' # Device Name
    lambda: |-
      std::string data_string(x.begin(), x.end());
      id(something_else_sensor).publish_state(data_string.c_str());
      return (float)x.size();
  # - platform: ble_client
  #   ble_client_id: apple_watch
  #   name: "char_2A01"
  #   service_uuid: '1800'
  #   characteristic_uuid: '2A01'

esp32_ble_tracker:
  scan_parameters:
    # interval: 1.2s
    # window: 500ms
    interval: 10s
    window: 100ms
    # TODO: maybe active scan collects more information and thus gives us tx_power and name?
    # Whether to actively send scan requests to request more data after having received an advertising packet. 
    # With some devices this is necessary to receive all data, but also drains those devices’ power a bit more. 
    # Some devices don’t need this, in that case you can save power and RF pollution by setting it to false. Defaults to true.
    # NOTE: seems changing this to true didn't magically provide the 
    active: true
  on_ble_advertise:
    - then:
        - lambda: |-
            for (auto data : x.get_manufacturer_datas()) {
              // Guard against non-Apple datagrams, or those that are too small.
              if (data.data.size() < 4 || data.uuid.to_string() != "0x004C" || data.data[0] != 0x10 || data.data[1] < 5) {
                continue;
              }
              const int16_t rssi = x.get_rssi();
              const uint8_t status_flags = data.data[2] >> 4;  // High nibble
              const uint8_t data_flags = data.data[3];
              // the apple watch is either locked or unlocked
              if (data_flags == 0x98 || data_flags == 0x18) {
                std::string result(x.get_tx_powers().begin(), x.get_tx_powers().end());
                ESP_LOGD("ble_adv", "New BLE device");
                ESP_LOGD("ble_adv", "  address: %s", x.address_str().c_str());
                ESP_LOGD("ble_adv", "  name: %s", x.get_name().c_str());
                ESP_LOGD("ble_adv", "  rssi: %i", x.get_rssi());
                ESP_LOGD("ble_adv", "  tx_powers: %s", result.c_str());
                ESP_LOGD("ble_adv", "  Advertised service UUIDs:");
                for (auto uuid : x.get_service_uuids()) {
                    ESP_LOGD("ble_adv", "    - %s", uuid.to_string().c_str());
                }
                ESP_LOGD("ble_adv", "  Advertised service data:");
                for (auto data : x.get_service_datas()) {
                    ESP_LOGD("ble_adv", "    - %s: (length %i)", data.uuid.to_string().c_str(), data.data.size());
                }
                ESP_LOGD("ble_adv", "  Advertised manufacturer data:");
                for (auto data : x.get_manufacturer_datas()) {
                    ESP_LOGD("ble_adv", "    - %s: (length %i)", data.uuid.to_string().c_str(), data.data.size());
                }
              }
            }