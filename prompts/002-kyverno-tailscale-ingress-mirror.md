<objective>
Update the libs/internal-networking Helm chart to add a Kyverno ClusterPolicy that automatically mirrors every nginx Ingress to a Tailscale Ingress in the same namespace, with external-dns CNAME annotations pointing to Tailscale MagicDNS names. Also update the external-dns HelmRelease to only process Tailscale ingress class resources.
</objective>

<context>
This is a Kubernetes infrastructure task in an Nx monorepo. The goal is to expose services both via nginx (public) and Tailscale (private/internal) with automatic DNS management.

Key components:
- `libs/internal-networking/` - Helm chart for Kyverno policies (currently has a basic label validation policy)
- `stacks/enigma-cluster/helmrelease-external-dns.yaml` - FluxCD HelmRelease for external-dns
- Tailscale operator is already deployed and provides the `tailscale` ingress class
- External-dns uses Cloudflare as the DNS provider

The generated Tailscale ingresses should:
1. Have `ingressClassName: tailscale` instead of `nginx`
2. Include an external-dns annotation to create CNAME records (not A records)
3. CNAME targets should point to `<ingress-name>.<tailscale-domain>` (e.g., `dashboard.tail2c33e2.ts.net`)

Read these files to understand the current state:
- `libs/internal-networking/templates/clusterpolicy.yaml`
- `libs/internal-networking/values.yaml`
- `libs/internal-networking/Chart.yaml`
- `stacks/enigma-cluster/helmrelease-external-dns.yaml`
</context>

<requirements>
1. **New ClusterPolicy** in `libs/internal-networking/templates/clusterpolicy-tailscale-ingress.yaml`:
   - Match all Ingress resources with `ingressClassName: nginx`
   - Exclude ingresses with annotation `tailscale-mirror/skip: "true"`
   - Exclude keycloak ingresses (match by name containing "keycloak" or namespace "keycloak")
   - Generate a new Ingress with name `<original-name>-tailscale` in the same namespace
   - Use `synchronize: true` so generated ingress is deleted when source is deleted
   - Use `generateExisting: true` to process existing ingresses on policy creation
   - Generated ingress must have:
     - `ingressClassName: tailscale`
     - `external-dns.alpha.kubernetes.io/hostname` annotation with original hostname
     - `external-dns.alpha.kubernetes.io/target` annotation pointing to `<ingress-name>.<tailscale-domain>`
     - Labels indicating it was generated by Kyverno
     - Use `defaultBackend` format (required by Tailscale ingress controller)
     - TLS configuration with the ingress name as the host

2. **Update values.yaml** to add configurable options:
   ```yaml
   tailscaleIngress:
     enabled: true
     tailscaleDomain: "tail2c33e2.ts.net"
     excludeNamespaces: []
     excludeNames:
       - keycloak
   ```

3. **Update external-dns HelmRelease** (`stacks/enigma-cluster/helmrelease-external-dns.yaml`):
   - Add `--ingress-class=tailscale` argument to only process Tailscale ingresses
   - Add `--policy=sync` to ensure DNS records are deleted when the corresponding ingress is removed
   - This ensures external-dns creates AND removes DNS records for the mirrored Tailscale ingresses
   - When a source nginx ingress is deleted, Kyverno removes the generated Tailscale ingress (due to `synchronize: true`), and external-dns with `policy=sync` will then remove the Cloudflare DNS record

4. **Bump chart version** in `libs/internal-networking/Chart.yaml` from 0.1.1 to 0.2.0 (minor version for new feature)
</requirements>

<constraints>
- Use Helm templating syntax correctly - escape curly braces in Kyverno JMESPath expressions using `{{` and `}}`
- Kyverno variables use `{{ request.object... }}` syntax which conflicts with Helm - use proper escaping
- The ClusterPolicy should be conditional on `.Values.tailscaleIngress.enabled`
- Follow the existing code style in the chart
- Do NOT modify the existing `clusterpolicy.yaml` - create a new file for the Tailscale ingress policy
- External-dns annotation for CNAME: use `external-dns.alpha.kubernetes.io/target` for the CNAME target
</constraints>

<implementation>
Example Kyverno ClusterPolicy structure (adapt for Helm templating):

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: generate-tailscale-ingress
spec:
  rules:
  - name: mirror-nginx-to-tailscale
    match:
      any:
      - resources:
          kinds:
          - Ingress
    preconditions:
      all:
      - key: "{{ request.object.spec.ingressClassName || '' }}"
        operator: Equals
        value: "nginx"
      - key: "{{ request.object.metadata.annotations.\"tailscale-mirror/skip\" || 'false' }}"
        operator: NotEquals
        value: "true"
    generate:
      synchronize: true
      generateExisting: true
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      name: "{{ request.object.metadata.name }}-tailscale"
      namespace: "{{ request.object.metadata.namespace }}"
      data:
        metadata:
          annotations:
            external-dns.alpha.kubernetes.io/hostname: "{{ request.object.spec.rules[0].host }}"
            external-dns.alpha.kubernetes.io/target: "{{ request.object.metadata.name }}.<tailscale-domain>"
        spec:
          ingressClassName: tailscale
          defaultBackend:
            service:
              name: "{{ request.object.spec.rules[0].http.paths[0].backend.service.name }}"
              port:
                number: "{{ request.object.spec.rules[0].http.paths[0].backend.service.port.number }}"
          tls:
            - hosts:
                - "{{ request.object.metadata.name }}"
```

For external-dns filtering and cleanup, add to the HelmRelease values:
```yaml
extraArgs:
  - --ingress-class=tailscale
  - --policy=sync
```

The `--policy=sync` setting is critical: it ensures external-dns removes DNS records from Cloudflare when the corresponding Tailscale ingress is deleted. Without this, orphaned DNS records would remain in Cloudflare after ingress deletion.
</implementation>

<output>
Modify these files:
- `libs/internal-networking/templates/clusterpolicy-tailscale-ingress.yaml` - NEW FILE with the ClusterPolicy
- `libs/internal-networking/values.yaml` - Add tailscaleIngress configuration
- `libs/internal-networking/Chart.yaml` - Bump version to 0.2.0
- `stacks/enigma-cluster/helmrelease-external-dns.yaml` - Add ingress class filter
</output>

<verification>
After making changes:
1. Run `helm template libs/internal-networking` to verify the chart renders correctly
2. Check that the ClusterPolicy YAML is valid and Kyverno expressions are properly escaped
3. Verify the external-dns HelmRelease has the correct extraArgs configuration
4. Ensure the chart version was bumped
</verification>

<success_criteria>
- ClusterPolicy correctly generates Tailscale ingresses from nginx ingresses
- Keycloak ingresses are excluded from mirroring
- External-dns is configured to only process tailscale ingress class
- External-dns uses `policy=sync` to remove DNS records when ingresses are deleted
- Generated ingresses have correct CNAME annotations for external-dns
- Helm chart renders without errors
- All Kyverno JMESPath expressions are properly escaped in Helm templates
- Full lifecycle works: nginx ingress created → Tailscale ingress generated → DNS record created → nginx ingress deleted → Tailscale ingress removed → DNS record removed
</success_criteria>
