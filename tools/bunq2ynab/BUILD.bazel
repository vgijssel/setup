load("@rules_python//python:defs.bzl", "py_binary")
load("@pip-setup//:requirements.bzl", "requirement")
load("@rules_task//:defs.bzl", "cmd", "task", "task_test")
load("@rules_pkg//pkg:tar.bzl", "pkg_tar")
load("//tools/bunq2ynab:rules.bzl", "pkg_executable")
load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

py_binary(
    name = "list_user_binary",
    srcs = ["@bunq2ynab//:list_user.py"],
    main = "list_user.py",
    deps = [
        "@bunq2ynab//:lib",
        requirement("requests"),
        requirement("pyopenssl"),
    ],
)

py_binary(
    name = "list_budget_binary",
    srcs = ["@bunq2ynab//:list_budget.py"],
    main = "list_budget.py",
    deps = [
        "@bunq2ynab//:lib",
        requirement("requests"),
        requirement("pyopenssl"),
    ],
)

py_binary(
    name = "bunq2ynab_binary",
    srcs = ["@bunq2ynab//:bunq2ynab.py"],
    main = "bunq2ynab.py",
    deps = [
        "@bunq2ynab//:lib",
        requirement("requests"),
        requirement("pyopenssl"),
    ],
)

task(
    name = "list_user",
    cmds = [
        "export OP_SERVICE_ACCOUNT_TOKEN=$ONEPASSWORD_SERVICE_ACCOUNT_TOKEN_DEV",
        "export CONFIG_FILE=$(pwd)/config.json",
        "$OP inject --in-file=$CONFIG_FILE_TPL --out-file=$CONFIG_FILE --force",
        {"defer": "rm -rf $CONFIG_FILE"},
        "$BINARY --config $CONFIG_FILE",
    ],
    env = {
        "BINARY": cmd.executable("list_user_binary"),
        "OP": cmd.executable("//tools/onepassword:op"),
        "CONFIG_FILE_TPL": cmd.file("config.json.tpl"),
    },
)

task_test(
    name = "list_user_test",
    cmds = [
        cmd.executable("list_user"),
    ],
)

task(
    name = "list_budget",
    cmds = [
        "export CONFIG_FILE=$(pwd)/config.json",
        "$OP inject --in-file=$CONFIG_FILE_TPL --out-file=$CONFIG_FILE --force",
        {"defer": "rm -rf $CONFIG_FILE"},
        "$BINARY --config $CONFIG_FILE",
    ],
    env = {
        "BINARY": cmd.executable("list_budget_binary"),
        "OP": cmd.executable("//tools/onepassword:op"),
        "CONFIG_FILE_TPL": cmd.file("config.json.tpl"),
    },
)

task(
    name = "bunq2ynab",
    cmds = [
        "export CONFIG_FILE=$(pwd)/config.json",
        "$OP inject --in-file=$CONFIG_FILE_TPL --out-file=$CONFIG_FILE --force",
        {"defer": "rm -rf $CONFIG_FILE"},
        "$BINARY --config $CONFIG_FILE",
    ],
    env = {
        "BINARY": cmd.executable("bunq2ynab_binary"),
        "OP": cmd.executable("//tools/onepassword:op"),
        "CONFIG_FILE_TPL": cmd.file("config.json.tpl"),
    },
)

py_binary(
    name = "generate_oauth_token_binary",
    srcs = ["@bunq2ynab//:generate_oauth_token.py"],
    main = "generate_oauth_token.py",
    deps = [
        "@bunq2ynab//:lib",
        requirement("requests"),
        requirement("pyopenssl"),
    ],
)

task(
    name = "generate_oauth_token",
    cmds = [
        "export CLIENT_ID=$($OP read op://vgijssel-dev/bunq2ynab_oauth/username)",
        "export CLIENT_SECRET=$($OP read op://vgijssel-dev/bunq2ynab_oauth/credential)",
        "$BINARY --oauth-client-id $CLIENT_ID --oauth-client-secret $CLIENT_SECRET",
    ],
    env = {
        "BINARY": cmd.executable("generate_oauth_token_binary"),
        "OP": cmd.executable("//tools/onepassword:op"),
    },
)

task(
    name = "kerk",
    cmds = [
        "echo kerk",
    ],
)

pkg_executable(
    name = "kerk_executable",
    bin = ":kerk",
    path = "kerk",
)

# TODO: currently the task does not run in the docker container
# because the runfiles structure is different breaking the runfiles functions.
# https://github.com/bazelbuild/rules_pkg/issues/392
# Two things still broken:
# 1. PYTHON_BINARY is hardcoded in the python runner. Can we get rid of this? Because the included Python does not seem to work.
#    maybe similar approach as rules_docker? Update the toolchain for the target or something?
# 2. The symlink is absolute not relative, maybe has something to do with how we extract in melango?
pkg_tar(
    name = "kerk_tar",
    srcs = [
        ":kerk_executable",
    ],
    include_runfiles = True,
    strip_prefix = ".",
)

# We have to use a custom packaging rule because rules_task is a custom executable
# What if rules_task outputs a py_binary? Then maybe we can use the python zip output group
# and package / upload this with Meltange and Apko!
#
# Steps to validate:
# 1. create py_binary target shine
# 2. zip up the py_binary target with output group
# 3. modify melange build to include the zip file
# 4. build the image with apko
# 5. load the image in docker
# 6. enjoy?!
# 7. also try py_binary with runfiles that includes another py_binary!
#
# Seems Python zip suffers from the same problems as pkg_executable, the python wrapper still contains a reference to the Python toolchain
# So how to remove the reference to the Python toolchain?
#

constraint_setting(name = "shine_containerized")

constraint_value(
    name = "shine_run_in_container",
    constraint_setting = ":shine_containerized",
)

platform(
    name = "shine_platform",
    constraint_values = [
        ":shine_run_in_container",
    ],
)

py_runtime(
    name = "shine_container_py2_runtime",
    interpreter_path = "/shine",
    python_version = "PY2",
)

py_runtime(
    name = "shine_container_py3_runtime",
    interpreter_path = "/shine",
    python_version = "PY3",
)

py_runtime_pair(
    name = "shine_container_py_runtime_pair",
    py2_runtime = ":shine_container_py2_runtime",
    py3_runtime = ":shine_container_py3_runtime",
)

# https://bazel.build/extending/platforms#:~:text=Execution%20%2D%20a%20platform%20on%20which,final%20output%20resides%20and%20executes.
# Not sure, but use exec_compatible_with instead of target_compatile_with because the latter
# has a different use case? Do we need both exec and target????
#
# target_compatible_with results into the expected value with this command:
# bazel build --toolchain_resolution_debug='@bazel_tools//tools/python:toolchain_type'  --platforms=//tools/bunq2ynab:shine_platform //tools/bunq2ynab:shine
#
# prints '/shine'
# cat /tmp/bazel-setup-bin/tools/bunq2ynab/shine | grep PYTHON_BINARY
toolchain(
    name = "shine_container_py_toolchain",
    # exec_compatible_with = [
    #     ":shine_run_in_container",
    # ],
    target_compatible_with = [
        ":shine_run_in_container",
    ],
    toolchain = ":shine_container_py_runtime_pair",
    toolchain_type = "@bazel_tools//tools/python:toolchain_type",
)

# Steps to use an alternative Python toolchain for container image:
# 1. Setup alternative Python toolchain
# 2. Setup alternative Platform
# 3. Create custom rule with transition pointing to alternative Platform
# 4. Profit?

py_binary(
    name = "shine",
    srcs = [
        "shine.py",
    ],
    # exec_compatible_with = [
    #     ":shine_run_in_container",
    # ],
    # target_compatible_with = [
    #     ":shine_run_in_container",
    # ],
    # exec_compatible_with = [
    #     # "@io_bazel_rules_docker//platforms:run_in_container",
    #     ":shine_run_in_container",
    #     # "@platforms//os:linux",
    #     # "@platforms//cpu:aarch64",
    # ],
    # target_compatible_with = [
    #     "@io_bazel_rules_docker//platforms:run_in_container",
    # ],
)
