subinclude("//tools/template")

PLEASE_ROOT_VAR = "please_root"
TERRAFORM_RC_TEMPLATE = ".terraformrc.templ"
TERRAFORM_RC = ".terraformrc"
TERRAFORM_MODULES_JSON = "modules.json"

def terraform_lock(name:str, providers_file: str, toolchain: str, visibility: list = None, test_only: bool = False):
    """Build rule to generate a script which will generate a lockfile from the given providers file.

    Idea is to run the lock script before building the terraform_providers rule so the build rule has the actual
    lock file download the appropriate versions. It's setup this way so the lockfile can be commited into version control.
    """
    sh_cmd(
        name = name,
        expand_env_vars = False,
        cmd = f"""
        set -Eeou pipefail

        TERRAFORM_BIN="$PWD/$(out_exe {toolchain})"
        PROVIDERS_FILE="$(out_location {providers_file})"
        PROVIDERS_DIR="$(dirname $PROVIDERS_FILE)"

        # Terraform only works with files in the same dir
        cd $PROVIDERS_DIR
        $TERRAFORM_BIN providers lock
        """,
        data = [
            toolchain,
            providers_file,
        ],
        visibility = visibility,
        test_only = test_only,
    )

def terraform_providers(name: str, providers_file: str, lock_file: str, toolchain: str, visibility: list = None, test_only:bool = False):
    """Build rule for downloading multiple terraform providers.
    """
    export_file(
        name = f"{name}_tf",
        src = providers_file,
        visibility = visibility,
        test_only = test_only,
    )

    genrule(
        name = name,
        srcs = [providers_file, lock_file],
        tools = {
            'terraform': toolchain,
        },
        outs = [f"{name}_mirror"],
        cmd = """
        # Terraform only works with files in the same dir
        OUT_DIR="$HOME/$OUTS"
        cd $PKG
        $TOOLS_TERRAFORM providers mirror $OUT_DIR
        """,
        visibility = visibility,
        test_only = test_only,
    )

def terraform_module(
        name: str, tf_srcs:list, modules: list = [],
        files:list = [], visibility: list = None,
        test_only: bool = False
    ):
    """Terraform module which can be included by a terraform (root) module.
    """

    return template(
        name = name,
        subs = files + modules,
        srcs = tf_srcs,
        transform = _add_tf_locations,
        visibility = visibility,
        test_only = test_only,
    )

# TODO: figure out to handle multiple named modules to match the module "<<NAME>>"
# in Terraform and how to include the files list into a single object for the template method.
# TODO: use relative paths instead of the custom constructed local urls for modules
# so we don't have the problem of module name having to match the name in the generated modules.json.
def terraform_root(
        name: str, tf_srcs:list, providers: list = [], modules: dict = {},
        files:list = [], toolchain: str, visibility: list = None,
        test_only: bool = False
    ):
    """Build rule for creating scripts which runs Terraform against a configuration.
    """

    # Create a terraformrc file which contains a provider_installation section
    # which for each provider will define a filesystem_mirror so files 
    # can be loaded by the Terraform runtime without accessing the network.
    # see https://www.terraform.io/docs/cli/config/config-file.html#provider_installation
    provider_tfs = [f"{provider}_tf" for provider in providers]
    filesystem_mirrors = ""

    for provider in providers:
        filesystem_mirrors += f"filesystem_mirror {{ path = \"$PLEASE_ROOT/$(out_location {provider})\" }}"

    terraformrc = text_file(
        name = f"{name}_terraformrc",
        data = providers,
        content = f"""
        provider_installation {{
            {filesystem_mirrors}
        }
        """,
        out = TERRAFORM_RC_TEMPLATE,
    )

    # module = modules.values()[0]

    # TODO: make this work for multiple modules
    # probably have to inline the _add_tf_locations function
    # and call the genrule at that time
    # genrule(
    #     name = f"{name}_module_path",
    #     deps = [
    #         module,
    #         f":{name}_terraformrc",
    #     ],
    #     cmd = f"""
    #     ANCHOR="$(out_dir :{name}_terraformrc)"
    #     MODULE="$(out_dir {module})"

    #     mkdir -p "$ANCHOR"
    #     mkdir -p "$MODULE"

    #     $TOOLS_COREUTILS/realpath --relative-to="$ANCHOR" "$MODULE" > $OUTS
    #     """,
    #     outs = [f"{name}_module_path"],
    #     visibility = visibility,
    #     test_only = test_only,
    #     tools = {
    #         'coreutils': '//third_party/gnu:coreutils',
    #     }
    # )

    modules_json = _create_modules_json(name, modules)

    # We signal the template rule that a module consists of multiple outputs
    # so the appropriate sequence replacement is used
    # for example $(locations ...) instead of $(location ...)
    modules = [template_build_label(src = module_label, has_multiple_outputs = True) for _, module_label in modules.items()]

    # Replace file paths in the source files with specially constructed absolute paths
    # so we don't have to copy source files into the Terraform working directory
    # which can be time consuming if the files are large (iso, disk images, etc).
    # Secondly replace module paths with special constructured local urls
    # which will resolve to modules built with Please.
    templated_tf_srcs = template(
        name = f"{name}_templated_root_tf_srcs",
        subs = files + modules,
        srcs = tf_srcs,
        transform = _add_tf_locations,
    )

    please_variables = text_file(
        name = f"{name}_please_variables",
        content = f"""
        variable "{PLEASE_ROOT_VAR}" {{
            type = string
        }}
        """,
        out = f"{name}_please_variables.tf",
    )

    # Construct the Terraform working directory where all the Terraform source files
    # will be on the same level. Terraform requires all source files to be in the same 
    # directory.
    wd_files = filegroup(
        name = f"{name}_wd",
        srcs = 
            [modules_json] +
            [templated_tf_srcs] + 
            [terraformrc] +
            [please_variables] +
            provider_tfs,
        visibility = visibility,
        test_only = test_only,
    )

    sh_cmd(
        name = name, 
        cmd = f"""
        set -Eeou pipefail

        export PLEASE_ROOT="$PWD"
        export TERRAFORM_WD="$PLEASE_ROOT/$(out_dir {wd_files})"
        export TERRAFORM_BIN="$PLEASE_ROOT/$(out_exe {toolchain})"

        cd $TERRAFORM_WD

        # This replaces the PLEASE_ROOT variable in the templated terraform rc file
        # which is necessary to get absolute paths for the file mirrors during runtime.
        cat {TERRAFORM_RC_TEMPLATE} | envsubst '$PLEASE_ROOT' > {TERRAFORM_RC}
        export TF_CLI_CONFIG_FILE="$TERRAFORM_WD/{TERRAFORM_RC}"

        # Create modules.json file which is used as a lookup for our local module urls
        # to folders on the local filesystem
        mkdir -p .terraform/modules
        cat {TERRAFORM_MODULES_JSON} | envsubst '$PLEASE_ROOT' > .terraform/modules/{TERRAFORM_MODULES_JSON}

        export TF_VAR_{PLEASE_ROOT_VAR}="$PLEASE_ROOT"

        $TERRAFORM_BIN init
        $TERRAFORM_BIN apply
        """,
        expand_env_vars = False,
        deps = [
            toolchain,
        ],
        srcs = [wd_files],
        visibility = visibility,
        test_only = test_only,
    )

# TODO: implement me
# get the out dir of //terraform/vagrant:vagrant
# compare this to the out dir the terraformrc (just to pick a random file)
# generate a relative path between the two 
# store the result in a file
# read this file using the template rule
def _add_tf_locations(transform_object:dict):
    values = transform_object.values
    original_value = values.original_value.value

    if values.has_multiple_outputs.value:
        values["tf_module_location"] = { "type": "string", "value": _create_module_url(original_value) }
    else:
        values["tf_file_location"] = { "type": "string", "value": f"${var.{PLEASE_ROOT_VAR}}/$(out_location {original_value})" }

def _create_modules_json(name:str, modules:dict) -> str:
    modules_data = [
        {
            "Key": "",
            "Source": "",
            "Dir": ".",
        },
    ]

    for name, module_label in modules.items():
        modules_data.append({
            "Key": name,
            "Source": _create_module_url(module_label),
            "Dir": f"$PLEASE_ROOT/$(out_dir {module_label})",
        })

    modules_data = {
        "Modules": modules_data,
    }

    return text_file(
        name = f"{name}_modules_json",
        content = json(modules_data),
        out = TERRAFORM_MODULES_JSON,
        data = modules,
    )

def _create_module_url(module_label:str) -> str:
    return f"https://localhost/$(out_dir {module_label})"