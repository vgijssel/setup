subinclude("//tools/template")

PLEASE_ROOT_VAR = "please_root"
TERRAFORM_RC_TEMPLATE = ".terraformrc.templ"
TERRAFORM_RC = ".terraformrc"

def terraform_lock(name:str, providers_file: str, toolchain: str, visibility: list = None, test_only: bool = False):
    """Build rule to generate a script which will generate a lockfile from the given providers file.

    Idea is to run the lock script before building the terraform_providers rule so the build rule has the actual
    lock file download the appropriate versions. It's setup this way so the lockfile can be commited into version control.
    """
    sh_cmd(
        name = name,
        expand_env_vars = False,
        cmd = f"""
        set -Eeou pipefail

        TERRAFORM_BIN="$PWD/$(out_exe {toolchain})"
        PROVIDERS_FILE="$(out_location {providers_file})"
        PROVIDERS_DIR="$(dirname $PROVIDERS_FILE)"

        # Terraform only works with files in the same dir
        cd $PROVIDERS_DIR
        $TERRAFORM_BIN providers lock
        """,
        data = [
            toolchain,
            providers_file,
        ],
        visibility = visibility,
        test_only = test_only,
    )

def terraform_providers(name: str, providers_file: str, lock_file: str, toolchain: str, visibility: list = None, test_only:bool = False):
    """Build rule for downloading multiple terraform providers.
    """
    export_file(
        name = f"{name}_tf",
        src = providers_file,
        visibility = visibility,
        test_only = test_only,
    )

    genrule(
        name = name,
        srcs = [providers_file, lock_file],
        tools = {
            'terraform': toolchain,
        },
        outs = [f"{name}_mirror"],
        cmd = """
        # Terraform only works with files in the same dir
        OUT_DIR="$HOME/$OUTS"
        cd $PKG
        $TOOLS_TERRAFORM providers mirror $OUT_DIR
        """,
        visibility = visibility,
        test_only = test_only,
    )

def terraform_root(
        name: str, tf_srcs:list, providers: list = [], modules: list = [],
        files:list = [], toolchain: str, visibility: list = None,
        test_only: bool = False
    ):
    """Build rule for creating scripts which runs Terraform against a configuration.
    """

    # Create a terraformrc file which contains a provider_installation section
    # which for each provider will define a filesystem_mirror so files 
    # can be loaded by the Terraform runtime without accessing the network.
    # see https://www.terraform.io/docs/cli/config/config-file.html#provider_installation
    provider_tfs = [f"{provider}_tf" for provider in providers]

    filesystem_mirrors = ""

    for provider in providers:
        filesystem_mirrors += f"filesystem_mirror {{ path = \"$PLEASE_ROOT/$(out_location {provider})\" }}"

    terraformrc = text_file(
        name = f"{name}_terraformrc",
        data = providers,
        content = f"""
        provider_installation {{
            {filesystem_mirrors}
        }
        """,
        out = TERRAFORM_RC_TEMPLATE,
    )

    # Replace file paths in the source files with specially constructed absolute paths
    # so we don't have to copy source files into the Terraform working directory
    # which can be time consuming if the files are large (iso, disk images, etc).
    # Secondly replace module paths with special constructured local urls
    # which will resolve to modules built with Please.

    # TODO: move the subs defining into the template build_def
    subs = {}
    deps = []

    for file in files:
        key = None

        if _is_build_label(file):
            target, label = decompose(canonicalise(file))
            key = f":{label}"
            deps.append(file)
        else:
            key = basename(file)

        subs[key] = file

    for module in modules:
        target, label = decompose(canonicalise(module))
        key = f":{label}"
        subs[key] = module

    templated_tf_srcs = template(
        name = f"{name}_templated_tf_srcs",
        subs = subs,
        deps = deps + modules,
        srcs = tf_srcs,
        transform = _add_tf_location,
    )

    please_variables = text_file(
        name = f"{name}_please_variables",
        content = f"""
        variable "{PLEASE_ROOT_VAR}" {{
            type = string
        }}
        """,
        out = f"{name}_please_variables.tf",
    )

    # Construct the Terraform working directory where all the Terraform source files
    # will be on the same level. Terraform requires all source files to be in the same 
    # directory.
    wd_files = filegroup(
        name = f"{name}_wd",
        srcs = [templated_tf_srcs] + [terraformrc] + [please_variables] + provider_tfs,
        visibility = visibility,
        test_only = test_only,
    )

    sh_cmd(
        name = name, 
        cmd = f"""
        set -Eeou pipefail

        export PLEASE_ROOT="$PWD"
        export TERRAFORM_WD="$PLEASE_ROOT/$(out_dir {wd_files})"
        export TERRAFORM_BIN="$PLEASE_ROOT/$(out_exe {toolchain})"

        cd $TERRAFORM_WD

        # This replaces the PLEASE_ROOT variable in the templated terraform rc file
        # which is necessary to get absolute paths for the file mirrors during runtime.
        cat {TERRAFORM_RC_TEMPLATE} | envsubst '$PLEASE_ROOT' > {TERRAFORM_RC}
        export TF_CLI_CONFIG_FILE="$TERRAFORM_WD/{TERRAFORM_RC}"

        export TF_VAR_{PLEASE_ROOT_VAR}="$PLEASE_ROOT"

        $TERRAFORM_BIN init
        $TERRAFORM_BIN apply
        """,
        expand_env_vars = False,
        deps = [
            toolchain,
        ],
        srcs = [wd_files],
        visibility = visibility,
        test_only = test_only,
    )

def _add_tf_location(key, value, aggregate) -> dict:
    aggregate["tf_location"] = f"${var.{PLEASE_ROOT_VAR}}/$(out_location {value})"
    return aggregate
