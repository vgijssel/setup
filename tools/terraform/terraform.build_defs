subinclude("//tools/template")

PLEASE_ROOT_VAR = "please_root"
TERRAFORM_RC_TEMPLATE = ".terraformrc.templ"
TERRAFORM_RC = ".terraformrc"

def terraform_lock(name:str, providers_file: str, toolchain: str, visibility: list = None, test_only: bool = False):
    """Build rule to generate a script which will generate a lockfile from the given providers file.

    Idea is to run the lock script before building the terraform_providers rule so the build rule has the actual
    lock file download the appropriate versions. It's setup this way so the lockfile can be commited into version control.
    """
    sh_cmd(
        name = name,
        expand_env_vars = False,
        cmd = f"""
        set -Eeou pipefail

        TERRAFORM_BIN="$PWD/$(out_exe {toolchain})"
        PROVIDERS_FILE="$(out_location {providers_file})"
        PROVIDERS_DIR="$(dirname $PROVIDERS_FILE)"

        # Terraform only works with files in the same dir
        cd $PROVIDERS_DIR
        $TERRAFORM_BIN providers lock
        """,
        data = [
            toolchain,
            providers_file,
        ],
        visibility = visibility,
        test_only = test_only,
    )

def terraform_providers(name: str, providers_file: str, lock_file: str, toolchain: str, visibility: list = None, test_only:bool = False):
    """Build rule for downloading multiple terraform providers.
    """
    export_file(
        name = f"{name}_tf",
        src = providers_file,
        visibility = visibility,
        test_only = test_only,
    )

    genrule(
        name = name,
        srcs = [providers_file, lock_file],
        tools = {
            'terraform': toolchain,
        },
        outs = [f"{name}_mirror"],
        cmd = """
        # Terraform only works with files in the same dir
        OUT_DIR="$HOME/$OUTS"
        cd $PKG
        $TOOLS_TERRAFORM providers mirror $OUT_DIR
        """,
        visibility = visibility,
        test_only = test_only,
    )

def terraform_module(
        name: str, tf_srcs:list, modules: list = [],
        files:list = [], subs:dict = None, visibility: list = None,
        test_only: bool = False
    ):
    """Terraform module which can be included by a terraform (root) module.
    """

    please_variables = _create_please_variables(name)

    templated_tf_srcs = template(
        name = f"_{name}#templated",
        subs = files + modules + _subs_to_list(subs),
        srcs = tf_srcs,
        transform = _add_tf_locations,
    )
    
    return filegroup(
        visibility = visibility,
        test_only = test_only,
        name = name,
        srcs = 
            [templated_tf_srcs] + 
            [please_variables]
    )

def terraform_root(
        name: str, tf_srcs:list, providers: list = [], modules: list = [],
        files:list = [], subs:dict = None, toolchain: str, visibility: list = None,
        test_only: bool = False
    ):
    """Build rule for creating scripts which runs Terraform against a configuration.
    """

    # Create a terraformrc file which contains a provider_installation section
    # which for each provider will define a filesystem_mirror so files 
    # can be loaded by the Terraform runtime without accessing the network.
    # see https://www.terraform.io/docs/cli/config/config-file.html#provider_installation
    provider_tfs = [f"{provider}_tf" for provider in providers]
    filesystem_mirrors = ""

    for provider in providers:
        filesystem_mirrors += f"filesystem_mirror {{ path = \"$PLEASE_ROOT/$(out_location {provider})\" }}"

    terraformrc = text_file(
        name = f"_{name}#terraformrc",
        data = providers,
        content = f"""
        provider_installation {{
            {filesystem_mirrors}
        }
        """,
        out = TERRAFORM_RC_TEMPLATE,
    )

    # We signal the template rule that a module consists of multiple outputs
    # so the appropriate sequence replacement is used
    # for example $(locations ...) instead of $(location ...)
    modules = [template_build_label(src = module_label, has_multiple_outputs = True) for module_label in modules]

    # Replace file paths in the source files with specially constructed absolute paths
    # so we don't have to copy source files into the Terraform working directory
    # which can be time consuming if the files are large (iso, disk images, etc).
    # Secondly replace module labels with relative paths within the out directory.
    # TODO: make files use the same relative path trick as modules! No need for the please variables added in
    templated_tf_srcs = template(
        name = f"_{name}#templated_root_tf_srcs",
        subs = files + modules + _subs_to_list(subs),
        srcs = tf_srcs,
        transform = _add_tf_locations,
    )

    please_variables = _create_please_variables(name)

    # Construct the Terraform working directory where all the Terraform source files
    # will be on the same level. Terraform requires all source files to be in the same 
    # directory.
    wd_files = filegroup(
        name = f"{name}_wd",
        srcs = 
            [templated_tf_srcs] + 
            [terraformrc] +
            [please_variables] +
            provider_tfs,
    )

    executable = sh_cmd(
        name = f"{name}_exe", 
        cmd = f"""
        set -Eeou pipefail

        # Make sure out custom SSH binary is in front of the PATH
        export PATH="$PWD/$(out_dir //tools/ssh):$PATH"
        export PLEASE_ROOT="$PWD"
        export TERRAFORM_WD="$PLEASE_ROOT/$(out_dir {wd_files})"
        export TERRAFORM_BIN="$PLEASE_ROOT/$(out_exe {toolchain})"

        cd $TERRAFORM_WD

        # This replaces the PLEASE_ROOT variable in the templated terraform rc file
        # which is necessary to get absolute paths for the file mirrors during runtime.
        cat {TERRAFORM_RC_TEMPLATE} | envsubst '$PLEASE_ROOT' > {TERRAFORM_RC}
        export TF_CLI_CONFIG_FILE="$TERRAFORM_WD/{TERRAFORM_RC}"

        # Finally set extra variables for Terraform runtime
        export TF_VAR_{PLEASE_ROOT_VAR}="$PLEASE_ROOT"

        $TERRAFORM_BIN init
        exec $TERRAFORM_BIN $@
        """,
        expand_env_vars = False,
        deps = [
            toolchain,
            "//tools/ssh"
        ],
        srcs = [wd_files],
    )

    def _create_callable_tf_command(command, args):
        sh_cmd(
            name = f"{name}_{command}",
            deps = [executable],
            cmd = f"""
            set -Eeou pipefail

            $(out_exe {executable}) {args} $@
            """,
            visibility = visibility,
            test_only = test_only,
            expand_env_vars = False,
        )

    _create_callable_tf_command("apply", "apply")
    _create_callable_tf_command("plan", "plan")
    _create_callable_tf_command("destroy", "destroy")
    _create_callable_tf_command("bin", "")

def _add_tf_locations(transform_object:dict, deps:dict):
    values = transform_object.values
    original_value = values.original_value.value

    if values.has_multiple_outputs.value:
        relative_module = _create_relative_module(transform_object)
        deps[relative_module] = True
        values["tf_module_location"] = { "type": "file", "value": f"$(location {relative_module})" }
    else:
        values["tf_file_location"] = { "type": "string", "value": f"${var.{PLEASE_ROOT_VAR}}/$(out_location {original_value})" }

def _create_relative_module(transform_object:dict):
    module = transform_object.values.build_label.value
    name = module.replace("/", "_").replace(":", "_")

    anchor = text_file(
        name = f"_{name}#anchor",
        content = "anchor",
    )

    return genrule(
        name = f"_{name}#module_path",
        deps = [
            module,
            anchor,
        ],
        cmd = f"""
        ANCHOR="$(out_dir {anchor})"
        MODULE="$(out_dir {module})"

        mkdir -p "$ANCHOR"
        mkdir -p "$MODULE"

        # echo without trailing newline
        echo -n "$($TOOLS_COREUTILS/realpath --relative-to="$ANCHOR" "$MODULE")" > $OUTS
        """,
        outs = [f"{name}_module_path"],
        tools = {
            'coreutils': '//third_party/gnu:coreutils',
        }
    )

def _subs_to_list(subs:dict) -> list:
    subs_list = []

    if subs == None:
        return subs_list

    for key, value in subs.items():
        subs_list.append(template_value(key, value))

    return subs_list


def _create_please_variables(name:str) -> str:
    return text_file(
        name = f"_{name}#please_variables",
        content = f"""
        variable "{PLEASE_ROOT_VAR}" {{
            type = string
        }}
        """,
        out = f"{name}_please_variables.tf",
    )