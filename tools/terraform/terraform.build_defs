subinclude("//tools/template")

TERRAFORM_RC_TEMPLATE = ".terraformrc.templ"
TERRAFORM_RC = ".terraformrc"

def terraform_lock(name:str, providers_file: str, toolchain: str, visibility: list = None, test_only: bool = False):
    """Build rule to generate a script which will generate a lockfile from the given providers file.

    Idea is to run the lock script before building the terraform_providers rule so the build rule has the actual
    lock file download the appropriate versions. It's setup this way so the lockfile can be commited into version control.
    """
    sh_cmd(
        name = name,
        cmd = f"""
        TERRAFORM_BIN="$PLEASE_ROOT/$(out_exe {toolchain})"
        PROVIDERS_FILE="$(out_location {providers_file})"
        PROVIDERS_DIR="$(dirname $PROVIDERS_FILE)"

        # Terraform only works with files in the same dir
        cd $PROVIDERS_DIR
        $TERRAFORM_BIN providers lock
        """,
        data = [
            toolchain,
            providers_file,
        ],
        visibility = visibility,
        test_only = test_only,
    )

def terraform_providers(name: str, providers_file: str, lock_file: str, toolchain: str, visibility: list = None, test_only:bool = False):
    """Build rule for downloading multiple terraform providers.
    """
    export_file(
        name = f"{name}_tf",
        src = providers_file,
        visibility = visibility,
        test_only = test_only,
    )

    genrule(
        name = name,
        srcs = [providers_file, lock_file],
        tools = {
            'terraform': toolchain,
        },
        outs = [f"{name}_mirror"],
        cmd = """
        # Terraform only works with files in the same dir
        OUT_DIR="$HOME/$OUTS"
        cd $PKG
        $TOOLS_TERRAFORM providers mirror $OUT_DIR
        """,
        visibility = visibility,
        test_only = test_only,
    )

def terraform_module(
        name: str, tf_srcs:list, modules: list = [],
        files:list = [], subs:dict = None, visibility: list = None,
        test_only: bool = False
    ):
    """Terraform module which can be included by a terraform (root) module.
    """

    templated_tf_srcs = template(
        name = f"_{name}#templated",
        subs = files + modules + _subs_to_list(subs),
        srcs = tf_srcs,
        transform = _add_tf_locations,
    )
    
    return filegroup(
        visibility = visibility,
        test_only = test_only,
        name = name,
        srcs = 
            [templated_tf_srcs]
    )

def terraform_root(
        name: str, tf_srcs:list, providers: list = [], modules: list = [],
        files:list = [], subs:dict = None, toolchain: str, visibility: list = None,
        test_only: bool = False, requires:list = []
    ):
    """Build rule for creating scripts which runs Terraform against a configuration.
    """

    # Create a terraformrc file which contains a provider_installation section
    # which for each provider will define a filesystem_mirror so files 
    # can be loaded by the Terraform runtime without accessing the network.
    # see https://www.terraform.io/docs/cli/config/config-file.html#provider_installation
    provider_tfs = [f"{provider}_tf" for provider in providers]
    filesystem_mirrors = ""

    for provider in providers:
        filesystem_mirrors += f"filesystem_mirror {{ path = \"$PLEASE_ROOT/$(out_location {provider})\" }}"

    terraformrc = text_file(
        name = f"_{name}#terraformrc",
        data = providers,
        content = f"""
        provider_installation {{
            {filesystem_mirrors}
        }
        """,
        out = TERRAFORM_RC_TEMPLATE,
        visibility = visibility,
        test_only = test_only,
    )

    # We signal the template rule that a module consists of multiple outputs
    # so the appropriate sequence replacement is used
    # for example $(locations ...) instead of $(location ...)
    modules = [template_build_label(src = module_label, has_multiple_outputs = True) for module_label in modules]

    # Use template to map files, modules and subs to paths relative to this rule.
    # This prevents us from copying source files into the Terraform working directory
    # which can be time consuming if the files are large (iso, disk images, etc).
    templated_tf_srcs = template(
        name = f"_{name}#templated_root_tf_srcs",
        subs = files + modules + _subs_to_list(subs),
        srcs = tf_srcs,
        transform = _add_tf_locations,
        requires = requires,
        visibility = visibility,
        test_only = test_only,
    )

    # Construct the Terraform working directory where all the Terraform source files
    # will be on the same level. Terraform requires all source files to be in the same 
    # directory.
    wd_files = filegroup(
        name = f"{name}_wd",
        srcs = 
            [templated_tf_srcs] + 
            [terraformrc] +
            provider_tfs,
        visibility = visibility,
        test_only = test_only,
    )

    data_dir = _label_to_safe_string(canonicalise(f":{name}"))

    executable = sh_cmd(
        name = f"{name}_exe", 
        cmd = f"""
        # Make sure out custom SSH binary is in front of the PATH
        export PATH="$PLEASE_ROOT/$(out_dir //tools/ssh):$PATH"

        export TERRAFORM_WD="$PLEASE_ROOT/$(out_dir {wd_files})"
        export TERRAFORM_BIN="$PLEASE_ROOT/$(out_exe {toolchain})"
        export TF_DATA_DIR="$PLEASE_ROOT/{CONFIG.TERRAFORM_DATA}/{data_dir}"

        cd $TERRAFORM_WD

        # This replaces the PLEASE_ROOT variable in the templated terraform rc file
        # which is necessary to get absolute paths for the file mirrors during runtime.
        cat {TERRAFORM_RC_TEMPLATE} | envsubst '$PLEASE_ROOT' > {TERRAFORM_RC}
        export TF_CLI_CONFIG_FILE="$TERRAFORM_WD/{TERRAFORM_RC}"

        exec $TERRAFORM_BIN $@
        """,
        deps = [
            toolchain,
            "//tools/ssh"
        ],
        srcs = [wd_files],
        visibility = visibility,
        test_only = test_only,
    )

    def _create_callable_tf_command(command, args):
        sh_cmd(
            name = f"{name}_{command}",
            deps = [executable],
            cmd = f"""
            $PLEASE_ROOT/$(out_exe {executable}) {args} $@
            """,
            visibility = visibility,
            test_only = test_only,
        )

    _create_callable_tf_command("init", "init")
    _create_callable_tf_command("apply", "apply")
    _create_callable_tf_command("plan", "plan")
    _create_callable_tf_command("destroy", "destroy")
    _create_callable_tf_command("bin", "")

def _add_tf_locations(transform_object:dict, transform_context:dict):
    values = transform_object.values
    original_value = values.original_value.value
    name = _label_to_safe_string(original_value)

    if values.is_value.value:
        location = original_value
        src = None
    elif values.is_build_label.value:
        if values.has_multiple_outputs.value:
            location = f"$(out_dir {original_value})"
        else:
            location = f"$(out_location {original_value})"
        src = original_value
    else:
        location = f"$(out_location {original_value})"
        src = original_value

    relative_path = _relative_path(name, src, location, transform_context.requires)
    deps = transform_context.deps
    deps[relative_path] = True
    values["tf_location"] = { "type": "file", "value": f"$(location {relative_path})" }

def _relative_path(name:str, src:str, value_location:str, requires:list):
    # This generates a file in the same directory this is being called from
    # this serves as the source or anchor of the relative path.
    anchor = text_file(
        name = f"_{name}#anchor",
        content = "anchor",
    )

    return genrule(
        name = f"_{name}#relative_path",
        deps = [
            anchor,
        ],
        srcs = [src],
        requires = requires,
        cmd = f"""
        ANCHOR="$(out_dir {anchor})"
        TARGET="{value_location}"

        mkdir -p "$ANCHOR"
        mkdir -p "$TARGET"

        # echo -n means without trailing newline
        echo -n "$($TOOLS_COREUTILS/realpath --relative-to="$ANCHOR" "$TARGET")" > $OUTS
        """,
        outs = [f"{name}_relative_path"],
        tools = {
            'coreutils': '//third_party/gnu:coreutils',
        }
    )

def _subs_to_list(subs:dict) -> list:
    subs_list = []

    if subs == None:
        return subs_list

    for key, value in subs.items():
        subs_list.append(template_value(key, value))

    return subs_list

def _label_to_safe_string(label:str) -> str:
    return label.replace("/", "_").replace(":", "_").replace(".", "_").replace("|", "_")