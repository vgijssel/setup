JINJA_SCRIPT = '//tools/template:jinja'

def template(name:str, subs:dict|list, srcs:list, test_only:bool = False, visibility:list = None, transform:function = None):
    """
    Generate a file using Jinja2 substitution.
    """

    # Note that deps is an object instead of an array
    # otherwise the iterate closure accessing deps
    # will always access an empty array for whatever reason.
    deps = {}
    data_object = {}
    new_srcs = []

    # NOTE: using inline function instead of lambda, because a function
    # can span multiple lines.
    def iterate(sub_key:str, sub_value:str|dict):
        value_object = _create_value_object(sub_value)
        key, value = _create_key_value_pair(sub_key, value_object)

        data_object[key] = value

        if transform != None:
            transform(key, value, data_object)

        if value.is_build_label or value.is_file:
            deps[value.original_value] = True

    _enumerate(subs, iterate)

    # We are not interested in the values of the dict which are all True
    deps = deps.keys()
    data = json(data_object)

    for src in srcs:
        # The _ and # combination make this rule hidden from build output.
        rule_name = "_" + name + "#" + basename(src)

        new_srcs.append(
            genrule(
                name = rule_name,
                srcs = {
                    "src": src,
                    # TODO: for some reason if we pass deps to deps of genrule only a 
                    # single dep is actually added to the build sandbox. Adding it here
                    # forces each file will be in the sandbox.
                    "deps": deps, 
                },
                outs = [src],
                tools = {
                    "JINJA_SCRIPT": JINJA_SCRIPT,
                },
                cmd = f"""
                DATA='{data}'
                $TOOLS_JINJA_SCRIPT "$SRCS_SRC" "$DATA" "$OUT"
                """,
                visibility = visibility,
                test_only = test_only,
            )
        )

    return filegroup(
        name = name,
        srcs = new_srcs,
        visibility = visibility,
        test_only = test_only,
    )

def template_build_label(src:str, has_multiple_outputs:bool = False):
    return {
        "is_build_label": True,
        "is_file": False,
        "has_multiple_outputs": has_multiple_outputs,
        "src": src,
    }

# TODO: remove this and replace with text_file
def template_value(name:str, value:str):
    return genrule(
        name = name,
        outs = [name],
        cmd = f"echo -n '{value}' > $OUT",
    )

def _is_build_label(string:str) -> bool:
    return string.startswith('//') or string.startswith(':')

def _is_file(string:str) -> bool:
    return string.startswith('/') or string.startswith('./') or string.startswith('../')

def _enumerate(iterable:list|dict, callback:function):
    if isinstance(iterable, dict):
        for key, value in iterable.items():
            callback(key, value)
    else:
        for value in iterable:
            callback(None, value)

def _create_value_object(value:str|dict) -> dict:
    if isinstance(value, dict):
        return value

    return {
        "is_build_label": _is_build_label(value),
        "is_file": _is_file(value),
        "src": value,
        "has_multiple_outputs": False,
    }

def _create_key_value_pair(key:str, value_object:dict) -> list:
    new_value = None

    if key == None:
        if value_object.is_build_label:
            target, label = decompose(canonicalise(value_object.src))
            key = f":{label}"
        elif value_object.is_file:
            key = basename(value_object.src)
        else:
            key = value_object.src

    if key == 'data':
        fail("data key for substitutions is reserved.") 

    if value_object.is_build_label or value_object.is_file:
        src = value_object.src

        if value_object.has_multiple_outputs:
            new_value = {
                "out_location": f"$(out_dir {src})",
                "location": f"$(dir {src})",
            }

        else:
            new_value = {
                "out_location": f"$(out_location {src})",
                "location": f"$(location {src})",
            }
        
        new_value['original_value'] = src

    else:
        new_value = {
            "value": value_object.src,
        }

    if value_object.is_build_label:
        new_value['build_label'] = canonicalise(value_object.src)

    new_value['is_build_label'] = value_object.is_build_label
    new_value['is_file'] = value_object.is_file

    return key, new_value