# Research: Agent Fleet Management Interface

**Feature**: 001-agent-fleet-interface
**Date**: 2025-10-27
**Phase**: 0 - Technology Research & Decision Documentation

## Overview

This document captures the research and technology decisions for building an MCP server that interfaces with Coder.com's AI tasks API to provide fleet management capabilities for AI agents running in Coder workspaces.

## Key Decisions

### 1. MCP Framework: FastMCP

**Decision**: Use FastMCP (https://github.com/jlowin/fastmcp) for MCP server implementation

**Rationale**:
- Pythonic, decorator-based API for defining MCP tools (`@mcp.tool()`)
- Built-in async/await support matching Coder API's async nature
- Handles MCP protocol serialization/deserialization automatically
- Active maintenance and growing adoption in MCP ecosystem
- Minimal boilerplate - focus on business logic, not protocol details

**Alternatives Considered**:
- **mcp-python** (Anthropic's reference implementation): More verbose, requires manual protocol handling, better for understanding MCP internals but slower development
- **Custom MCP implementation**: Violates "minimal code" principle; significant protocol complexity with no added value
- **Alternative protocols (gRPC, REST)**: MCP is specifically designed for AI agent tool use and is the standard for Claude/superagent integrations

**Implementation Notes**:
- FastMCP version will be pinned in requirements.txt (e.g., `fastmcp==0.5.0`)
- Server initialization in `server.py` with tool auto-discovery from `tools/` package
- Each tool will be an async function with type hints for automatic schema generation

### 2. HTTP Client: httpx

**Decision**: Use httpx for Coder API HTTP communication

**Rationale**:
- Async/await native support - essential for concurrent agent queries
- Modern API design with excellent type hints for IDE support
- HTTP/2 support for potential connection reuse across multiple API calls
- Well-maintained with broad adoption (pytest-httpx available for testing)
- Drop-in replacement for requests with async capabilities

**Alternatives Considered**:
- **requests**: Synchronous only; would require threading or asyncio.to_thread wrappers, adding complexity
- **aiohttp**: More low-level, requires manual session management, heavier dependency
- **urllib3**: Too low-level, no async support, would need significant wrapper code

**Implementation Notes**:
- Single `AsyncClient` instance reused across MCP tool calls
- Base URL configured from environment: `https://macbook-pro-van-maarten.tail2c33e2.ts.net`
- Timeout configuration: 30s for standard calls, 60s for log streaming
- Automatic retry logic for transient failures (503, connection errors)

### 3. Secret Management: Environment Variables + Nx Secrets Target

**Decision**: Use environment variables loaded from `.env` file generated by Nx `secrets` target

**Rationale**:
- Nx integration: `nx secrets coder-mcp` runs `op` CLI to generate `.env` file
- Standard environment variable approach - no SDK dependencies
- `.env` file gitignored, regenerated on-demand per developer
- Consistent with Nx monorepo patterns for secret management
- Simple python-dotenv library for loading

**Alternatives Considered**:
- **1password-sdk**: Adds SDK dependency; not needed when `op` CLI already available
- **Direct op CLI calls in code**: Tight coupling to 1Password; harder to test
- **Vault/Consul**: Adds infrastructure dependency, overkill for single-secret use case
- **Encrypted files**: Manual key management burden, rotation complexity

**Implementation Notes**:
- Nx `secrets` target in `project.json`: runs `op read "op://setup-devenv/coder-speckit/credential" > .env`
- Environment variable name: `CODER_SESSION_TOKEN`
- python-dotenv loads `.env` on startup in `config.py`
- Auth header format: `Coder-Session-Token: {token}`
- Error handling for missing env var with clear instructions to run `nx secrets coder-mcp`

### 4. Package Manager: uv (Native Workflow)

**Decision**: Use uv's native workflow with `pyproject.toml` and `uv.lock` for dependency management

**Rationale**:
- **Speed**: 10-100x faster than pip for installations (written in Rust)
- **Native Python packaging**: Uses PEP 621 `pyproject.toml` standard (same as Poetry, PDM)
- **Lockfile**: `uv.lock` provides deterministic, reproducible installs (like package-lock.json)
- **Unified tool**: Package management + venv + command runner + Python version management
- **Command runner**: `uv run` executes commands in the project's virtual environment automatically
- **Simple workflow**: `uv add` to add deps, `uv sync` to install, `uv remove` to remove
- **Dev dependencies**: Optional dependencies in `[project.optional-dependencies]` section

**Alternatives Considered**:
- **pip + requirements.txt**: Traditional but lacks lockfile, slower, manual venv management
- **poetry**: Feature-complete but slower than uv, more opinionated
- **pipenv**: Outdated, slow, less active maintenance
- **uv pip mode**: Backwards compatible but doesn't leverage uv's full potential

**Implementation Notes**:
- Install uv: `curl -LsSf https://astral.sh/uv/install.sh | sh` or via package manager
- Initialize project: `uv init` creates pyproject.toml (or create manually)
- Add dependency: `uv add fastmcp==0.5.0 httpx==0.27.0 pydantic==2.5.0`
- Add dev dependency: `uv add --dev pytest==8.0.0 pytest-asyncio==0.23.0 vcrpy==5.1.0`
- Sync dependencies: `uv sync` (installs from lockfile, creates venv if needed)
- Run commands: `uv run pytest` (automatically activates venv)
- Lock file: `uv.lock` committed to git for reproducible builds
- Python version: Specify in pyproject.toml: `requires-python = ">=3.12"`

**pyproject.toml Structure**:
```toml
[project]
name = "coder-mcp"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = [
    "fastmcp==0.5.0",
    "httpx==0.27.0",
    "pydantic==2.5.0",
    "python-dotenv==1.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest==8.0.0",
    "pytest-asyncio==0.23.0",
    "vcrpy==5.1.0",
    "pytest-cov==4.1.0",
    "mypy==1.8.0",
]
```

### 5. Data Models: Pydantic

**Decision**: Use Pydantic v2 for Coder API response parsing and validation

**Rationale**:
- Type-safe data classes with automatic validation
- JSON serialization/deserialization built-in
- Field aliases for mapping Coder's snake_case API to Pythonic naming
- Rich error messages for debugging API contract mismatches
- Performance improvements in v2 (Rust core)

**Alternatives Considered**:
- **Dataclasses**: No validation, manual JSON handling, type hints not enforced at runtime
- **attrs**: Less ecosystem support, no async validators, fewer integrations
- **TypedDict**: No runtime validation, just type hints

**Implementation Notes**:
- Models defined in `models.py` matching Coder API schema
- Key models: `Agent`, `Task`, `TaskStatus`, `LogEntry`, `WorkspaceBuild`
- Validation for required fields, enum values, timestamp parsing

### 6. Testing Strategy

**Decision**: pytest with pytest-asyncio, vcrpy (python-vcr), and contract testing approach

**Rationale**:
- **pytest-asyncio**: Native async test support matching async MCP tools
- **vcrpy**: Record/replay real HTTP interactions with Coder API as fixtures
  - Captures actual API responses (better than mocks for accuracy)
  - Fixtures stored as YAML "cassettes" in `tests/fixtures/`
  - First run records real API calls, subsequent runs replay from cassettes
  - Tests work offline after initial recording
- **Contract tests**: Validate MCP tool schemas match superagent expectations
- **Integration tests**: Full flow testing with VCR-recorded Coder API responses

**VCR Benefits Over Mocks**:
- Real API responses prevent drift between mocks and actual behavior
- Easier to update when API changes (just delete cassette and re-record)
- No manual mock construction - automatic capture
- Validates HTTP request details (headers, auth, query params)

**Test Coverage Goals**:
- Unit tests: 90%+ for `client.py`, `config.py`, `models.py`
- Contract tests: 100% of MCP tools (schema validation)
- Integration tests: Happy path + error scenarios for each tool (VCR fixtures)

**Alternatives Considered**:
- **pytest-httpx mocks**: Manual mock construction; mocks can drift from real API
- **unittest**: Less Pythonic, verbose setup/teardown, no fixture support
- **nose2**: Declining maintenance, smaller ecosystem than pytest
- **responses library**: Similar to pytest-httpx; manual mock definition

**Implementation Notes**:
- VCR cassettes in `tests/fixtures/cassettes/` (YAML format)
- Cassette naming: `{test_module}/{test_function}.yaml`
- Sensitive data filtering: VCR config to redact tokens in cassettes
- Test fixtures in `tests/conftest.py` for VCR configuration, credentials
- Separate test files per module: `test_client.py`, `test_tools.py`, etc.
- CI integration with Nx: `nx test coder-mcp` runs full test suite with cassettes
- Regenerate cassettes: `uv run pytest --record-mode=rewrite` or delete cassette files

### 7. MCP Tool Design

**Decision**: Map each Coder API endpoint to a dedicated MCP tool with clear names

**Tool Mapping**:
| MCP Tool | Coder API Endpoint | Purpose |
|----------|-------------------|---------|
| `list_agents` | GET /api/experimental/tasks | List all AI task agents |
| `get_agent_details` | GET /api/experimental/tasks/{user}/{id} | Get specific agent status |
| `create_agent_task` | POST /api/experimental/tasks/{user} | Create new AI task/agent |
| `delete_agent` | POST /api/v2/workspaces/{id}/builds (transition=delete) | Delete agent workspace |
| `send_agent_input` | POST /api/experimental/tasks/{user}/{id}/send | Send input to running agent |
| `get_agent_logs` | GET /api/experimental/tasks/{user}/{id}/logs | Retrieve agent execution logs |

**Rationale**:
- 1:1 mapping reduces cognitive overhead; tool name clearly indicates Coder endpoint
- Stateless design - each tool call is independent, fetches fresh data from Coder
- Error handling at tool level - translate Coder API errors to user-friendly messages
- Input validation via Pydantic models before API calls

**Implementation Notes**:
- Each tool in separate file under `tools/` for modularity
- Shared error handling via decorator pattern
- Consistent response format: `{"success": bool, "data": ..., "error": ...}`

### 8. Nx Integration

**Decision**: Integrate as standard Nx library with Python support

**Configuration Files**:
- **package.json**: Defines library metadata, scripts for Nx executors
- **project.json**: Nx targets (build, test, lint) using Python executors
- **pyproject.toml**: Python packaging metadata (PEP 518 standard)
- **requirements.txt**: Pinned dependencies (not `^` or `~` versions)

**Nx Targets**:
```json
{
  "build": "nx run coder-mcp:build",
  "test": "nx run coder-mcp:test",
  "lint": "nx run coder-mcp:lint"
}
```

**Rationale**:
- Consistent developer experience with other libs/apps in monorepo
- Nx caching for test/build results
- Dependency graph visualization: `nx graph`
- Affected command optimization: `nx affected:test`

**Implementation Notes**:
- Python executor from `@nxlv/python` plugin
- Lint target runs `trunk check` on Python files
- Build target validates packaging with `uv build --check`

### 9. Error Handling Strategy

**Decision**: Layered error handling with context preservation

**Layers**:
1. **Network errors**: httpx retries with exponential backoff
2. **API errors**: Map Coder HTTP status codes to specific exceptions
3. **Validation errors**: Pydantic validation failures with field-level details
4. **MCP errors**: Translate internal errors to MCP-compatible error responses

**Error Types**:
- `CoderAPIError`: Base exception for all Coder API failures
- `AgentNotFoundError`: 404 from Coder API
- `AuthenticationError`: 401/403 from Coder API
- `ValidationError`: Pydantic validation failures

**Rationale**:
- Superagent receives actionable error messages
- Logging at each layer for debugging
- No silent failures - all errors surfaced to caller
- Error context preserved across layers (agent ID, endpoint, HTTP status)

**Implementation Notes**:
- Exception hierarchy in `exceptions.py`
- Error logging with structured context (JSON)
- Error responses include suggested next steps for user

## Dependencies Summary

All dependencies managed in `pyproject.toml` with exact versions pinned in `uv.lock`.

### Production Dependencies
```bash
# Add with: uv add <package>==<version>
fastmcp==0.5.0          # MCP server framework
httpx==0.27.0           # Async HTTP client
pydantic==2.5.0         # Data validation and models
python-dotenv==1.0.0    # Environment variable loading
```

### Development Dependencies
```bash
# Add with: uv add --dev <package>==<version>
pytest==8.0.0
pytest-asyncio==0.23.0
vcrpy==5.1.0            # HTTP request/response recording
pytest-cov==4.1.0
black==24.1.0           # Code formatting
ruff==0.1.0             # Linting
mypy==1.8.0             # Type checking
```

**Installation**: `uv sync` installs all dependencies from `uv.lock`

## Open Questions / Future Research

None - all technology decisions finalized for Phase 1 design.

## References

- FastMCP: https://github.com/jlowin/fastmcp
- Coder AI Tasks API: https://github.com/coder/coder/blob/main/coderd/aitasks.go
- MCP Specification: https://modelcontextprotocol.io/
- httpx Documentation: https://www.python-httpx.org/
- VCR.py Documentation: https://vcrpy.readthedocs.io/
- python-dotenv: https://github.com/theskumar/python-dotenv
- uv Documentation: https://docs.astral.sh/uv/
