---
- name: "Provision digitalrebar"
  hosts: all
  gather_facts: true

  tasks:
    - name: Setup digitalrebar
      delegate_to: localhost
      tags: ["config"]
      block:
        - name: Copy license
          command: "{{ drpcli }} contents upload {{ license }}"

        # TODO: we can pre-compile the task libraries and upload them
        # so installation might go a bit faster / reproducible.
        - name: Install task library
          command: "{{ drpcli }} catalog item install task-library"

        - name: Install community content
          command: "{{ drpcli }} catalog item install drp-community-content"

        - name: Install image deploy content pack
          command: "{{ drpcli }} catalog item install image-deploy"

        - name: Ensure logs are forwarded to console port
          command: "{{ drpcli }} profiles set global param kernel-console to 'console=tty0 console=ttyS0,115200'"

        # TODO: replace with vault
        - name: Get public key content
          set_fact:
            public_key: "{{ lookup('file', public_key_path) }}"

        - name: Generate access keys param json
          set_fact:
            access_keys: "{{ lookup('template', './access_keys.json.j2') }}"

        - name: Set public key in digital rebar
          command: '{{ drpcli }} profiles set global param access-keys to "{{ access_keys }}"'

        - name: Upload discover_new
          command: "{{ drpcli }} contents upload {{ discover_new }}"

        # TODO: default workflow should be ignore, only if the machine is known we should handle it
        - name: Set default workflow
          command: "{{ drpcli }} prefs set defaultWorkflow discover_new unknownBootEnv discovery"

    - name: Collect network information
      tags: ["network"]
      set_fact:
        network_data: "{{ ansible_enp0s8 }}"

    - name: Adapter config
      tags: ["network"]
      debug:
        msg: "{{ ansible_enp0s8 }}"

    - name: All config
      tags: ["network"]
      debug:
        msg: "{{ ansible_facts }}"

    - set_fact:
      tags: ["network"]
      set_fact:
        network_interface: "{{ network_data.device }}"
        network_netmask: "{{ network_data.ipv4.netmask }}"
        network_broadcast: "{{ network_data.ipv4.broadcast }}"
        network_cidr: "{{ network_data.ipv4.network }}/{{ network_data.ipv4.netmask }}"
        provisioner_ip: "{{ network_data.ipv4.address }}"
        # network_router: "{{ network_data.gateway }}"
        # network_dns: "{{ network_data.gateway }}"
        # network_dns_search: "{{ ansible_dns.search[0] }}"

    - name: Generate actual cidr
      tags: ["network"]
      set_fact:
        network_cidr: "{{ network_cidr | ansible.netcommon.ipaddr('net') }}"

    - name: Generate dhcp range
      tags: ["network"]
      set_fact:
        network_dhcp_start: "{{ network_cidr | ansible.netcommon.ipaddr('first_usable') }}"
        network_dhcp_end: "{{ network_cidr | ansible.netcommon.ipaddr('last_usable') }}"

    - name: Generate subnet config
      tags: ["network"]
      set_fact:
        subnet_config: "{{ lookup('template', './subnet.json.j2') }}"

    - name: Get existing subnet
      tags: ["network"]
      delegate_to: localhost
      command: "{{ drpcli }} subnets list"
      register: existing_subnets

    - name: Delete existing subnet
      tags: ["network"]
      delegate_to: localhost
      command: "{{ drpcli }} subnets destroy {{ network_interface }}"
      when: existing_subnets.stdout | from_json | selectattr('Name', 'equalto', network_interface) | length > 0

    - name: Create subnet
      tags: ["network"]
      delegate_to: localhost
      command: '{{ drpcli }} subnets create "{{ subnet_config }}"'
